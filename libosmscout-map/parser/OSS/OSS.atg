#include <limits>
#include <list>
#include <sstream>

#include <osmscout/Pixel.h>

#include <osmscout/TypeConfig.h>

#include <osmscout/util/String.h>
#include <osmscout/util/Transformation.h>

COMPILER OSS

typedef std::list<FillStyleRef>       FillStyleList;
typedef std::list<BorderStyleRef>     BorderStyleList;
typedef std::list<IconStyleRef>       IconStyleList;
typedef std::list<TextStyleRef>       TextStyleList;
typedef std::list<LineStyleRef>       LineStyleList;
typedef std::list<PathTextStyleRef>   PathTextStyleList;
typedef std::list<PathShieldStyleRef> PathShieldStyleList;

StyleConfig&                          config;
MagnificationConverter                magnificationConverter;
bool                                  state;

enum class ValueType
{
  NO_VALUE,
  IDENT,
  STRING,
  COLOR,
  NUMBER,
  CONSTANT
};

std::string Destring(const char* str)
{
  std::string result(str);

  if (result.length()>=2 &&
      result[0]=='"' &&
      result[result.length()-1]=='"') {
    result=result.substr(1,result.length()-2);
  }

  return result;
}

bool StringToDouble(const char* string, double& value)
{
  std::istringstream buffer(string);

  buffer.imbue(std::locale::classic());

  buffer >> value;

  return !buffer.fail() && !buffer.bad() && buffer.eof();
}

size_t GetHexDigitValue(char c)
{
  if (c>='0' && c<='9') {
    return c-'0';
  }
  else if (c>='a' && c<='f') {
    return 10+(c-'a');
  }

  assert(false);
  return 0;
}

void AddFeatureToFilter(StyleFilter& filter,
                        const std::string& featureName,
                        TypeInfoSet& resultTypes)
{
  FeatureRef feature=config.GetTypeConfig()->GetFeature(featureName);

  if (!feature) {
    std::string e="Unknown feature '"+featureName+"'";

    SemErr(e.c_str());
    return;
  }

  for (const auto& type : config.GetTypeConfig()->GetTypes()) {
    if (type->HasFeature(featureName)) {
      if (!filter.FiltersByType() ||
          filter.HasType(type)) {
        // Add type only if the filter either has no types or 
        // if the the type is already filtered  
        resultTypes.Set(type);
      }
    }
  }

  if (!resultTypes.Empty()) {
    size_t featureFilterIndex=config.GetFeatureFilterIndex(*feature);
  
    filter.AddFeature(featureFilterIndex);
  }
}

CHARACTERS
  letter     = 'a'..'z' + 'A'..'Z'.
  digit      = '0'..'9'.
  hexdigit   = 'a'..'f' + '0'..'9'.
  eol        = '\n'.
  stringchar = ANY - '"'.
  quotchar   = ANY.

TOKENS
  ident      = ('_' | letter) {letter | digit | '_'}.
  number     = digit {digit}.
  double     = digit {digit} '.' digit {digit}.
  color      = "#" hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit [hexdigit hexdigit].
  variable   = "@" ('_' | letter) {letter | digit | '_'}.
  string     = '"' {stringchar | '\\' quotchar} '"'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO eol

IGNORE ' ' + '\t' + '\r' + '\n'

PRODUCTIONS
  OSS         = SYNC "OSS"
                (. state=true; .)
                {
                  FLAGSECTION
                }
                [
                  WAYORDER
                ]
                {
                  CONSTSECTION
                }
                {
                  SYMBOLSECTION
                }
                {
                  STYLESECTION
                }
                "END"
                .

  FLAGSECTION = SYNC "FLAG"
                FLAGBLOCK<true>
                .

  FLAGBLOCK<bool state>
              = {
                    FLAGDEF
                  | FLAGCONDBLOCK<state>
                }
                .

  FLAGCONDBLOCK<bool state>
              =  (.
                   bool newState=state;
                   bool executed=false;
                 .)
                 "IF"
                 IFCOND<newState>
                 "{"
                 (.
                   this->state=state && newState;
                 .)
                 FLAGBLOCK<state && newState>
                 (.
                   this->state=state;
                   executed=newState;
                 .)
                 "}"
                 {
                   "ELIF"
                   IFCOND<newState>
                   "{"
                   (.
                     this->state=!executed && state && newState;
                   .)
                   FLAGBLOCK<!executed && state && newState>
                   (.
                     this->state=state;
                     executed=newState;
                   .)
                   "}"
                 }
                 [
                   "ELSE"
                   "{"
                   (.
                     this->state=!executed && state;
                   .)
                   FLAGBLOCK<!executed && state>
                   (.
                     this->state=state;
                   .)
                   "}"
                 ]
                 .

  FLAGDEF     = (.
                  std::string name;
                  bool        value;
                .)
                IDENT<name>
                "="
                BOOL<value>
                (.
                  if (state) {
                    if (!config.HasFlag(name)) {
                      config.AddFlag(name,value);
                    }
                  }
                .)
                ";"
                .

  WAYORDER    = SYNC "ORDER" "WAYS"
                (. size_t priority=1;.)
                {
                  WAYGROUP<priority>
                  (. priority++;.)
                }
                .

  WAYGROUP<size_t priority>
              = SYNC "GROUP"
                [
                  (.
                     std::string wayTypeName;
                     TypeInfoRef wayType;
                  .)
                  IDENT<wayTypeName>
                  (.
                      wayType=config.GetTypeConfig()->GetTypeInfo(wayTypeName);

                      if (!wayType) {
                        std::string e="Unknown way type '"+wayTypeName+"'";
                        SemWarning(e.c_str());
                      }
                      else if (!wayType->CanBeWay()) {
                        std::string e="Tyype '"+wayTypeName+"' is not a way type";
                        SemErr(e.c_str());
                      }
                      else {
                        config.SetWayPrio(wayType,
                                          priority);
                      }
                  .)
                ]
                {
                  (.
                     std::string wayTypeName;
                     TypeInfoRef wayType;
                  .)
                  ","
                  IDENT<wayTypeName>
                  (.
                      wayType=config.GetTypeConfig()->GetTypeInfo(wayTypeName);

                      if (!wayType) {
                        std::string e="Unknown way type '"+wayTypeName+"'";
                        SemWarning(e.c_str());
                      }
                      else if (!wayType->CanBeWay()) {
                        std::string e="Tyype '"+wayTypeName+"' is not a way type";
                        SemErr(e.c_str());
                      }
                      else {
                        config.SetWayPrio(wayType,
                                          priority);
                      }
                  .)
                }
                .

  SYMBOLSECTION
              = SYNC "SYMBOL"
                (.
                  std::string name;
                .)
                IDENT<name>
                (.
                  SymbolRef symbol=std::make_shared<Symbol>(name);
                .)
                {
                  POLYGON<*symbol>
                | RECTANGLE<*symbol>
                | CIRCLE<*symbol>
                }
                (.
                  if (!config.RegisterSymbol(symbol)) {
                    std::string e="Map symbol '"+symbol->GetName()+"' is already defined";
                    SemErr(e.c_str());
                  }
                .)
                .

  AREAFILLSYMSTYLE<FillPartialStyle& fillStyle>
              = SYNC "{"
                {
                  FILLSTYLEATTR<fillStyle> WEAK ";"
                }
                "}"
                .

  AREABORDERSYMSTYLE<BorderPartialStyle& borderStyle>
              = SYNC "BORDER" "{"
                {
                  BORDERSTYLEATTR<borderStyle> WEAK ";"
                }
                "}"
                .

  AREASYMBOLSTYLE<FillPartialStyle& fillStyle, BorderPartialStyle& borderStyle>
              = SYNC "{"
                {
                  SYNC "AREA" 
                  (  
                    AREAFILLSYMSTYLE<fillStyle>
                  | "."
                    (
                      AREABORDERSYMSTYLE<borderStyle>
                    )  
                  )  
                }
                SYNC "}"
                .

  POLYGON<Symbol& symbol>
              = SYNC "POLYGON"
                (.
                  StyleFilter         filter;
                  FillPartialStyle    fillStyle;
                  BorderPartialStyle  borderStyle;
                  PolygonPrimitiveRef polygon=std::make_shared<PolygonPrimitive>(fillStyle.style,
                                                                                 borderStyle.style);
                  Vertex2D            coord;
                .)
                COORD<coord>   (. polygon->AddCoord(coord); .)
                COORD<coord>   (. polygon->AddCoord(coord); .)
                {
                  COORD<coord> (. polygon->AddCoord(coord); .)
                }
                AREASYMBOLSTYLE<fillStyle,borderStyle>
                (. symbol.AddPrimitive(polygon); .)
                .

  RECTANGLE<Symbol& symbol>
              = SYNC "RECTANGLE"
                (.
                  StyleFilter        filter;
                  FillPartialStyle   fillStyle;
                  BorderPartialStyle borderStyle;
                  Vertex2D           topLeft;
                  double             width;
                  double             height;
                .)
                COORD<topLeft>
                UDOUBLE<width>
                "x"
                UDOUBLE<height>

                AREASYMBOLSTYLE<fillStyle,borderStyle>
                (.
                  symbol.AddPrimitive(std::make_shared<RectanglePrimitive>(topLeft,
                                                                           width,height,
                                                                           fillStyle.style,
                                                                           borderStyle.style));
                .)
                .

  CIRCLE<Symbol& symbol>
              = SYNC "CIRCLE"
                (.
                  Vertex2D           center;
                  double             radius;
                  StyleFilter        filter;
                  FillPartialStyle   fillStyle;
                  BorderPartialStyle borderStyle;
                .)
                COORD<center>
                UDOUBLE<radius>
                AREASYMBOLSTYLE<fillStyle,borderStyle>
                (.
                  symbol.AddPrimitive(std::make_shared<CirclePrimitive>(center,
                                                                        radius,
                                                                        fillStyle.style,
                                                                        borderStyle.style));
                .)
                .

  COORD<Vertex2D& coord>
              = (.
                  double x;
                  double y;
                .)
                DOUBLE<x>
                 ","
                DOUBLE<y>
                (. coord=Vertex2D(x,y); .)
                .

  CONSTSECTION
              = SYNC "CONST"
                CONSTBLOCK<true>
                .

  CONSTBLOCK<bool state>
              = {
                    CONSTCONDBLOCK<state>
                  | CONSTDEF ";"
                }
                .

  CONSTCONDBLOCK<bool state>
              =  (.
                   bool newState=state;
                   bool executed=false;
                 .)
                 "IF"
                 IFCOND<newState>
                 "{"
                 (.
                   this->state=state && newState;
                 .)
                 CONSTBLOCK<state && newState>
                 (.
                   this->state=state;
                   executed=newState;
                 .)
                 "}"
                 {
                   "ELIF"
                   IFCOND<newState>
                   "{"
                   (.
                     this->state=!executed && state && newState;
                   .)
                   CONSTBLOCK<!executed && state && newState>
                   (.
                     this->state=state;
                     executed=newState;
                   .)
                   "}"
                 }
                 [
                   "ELSE"
                   "{"
                   (.
                     this->state=!executed && state;
                   .)
                   CONSTBLOCK<!executed && state>
                   (.
                     this->state=state;
                   .)
                   "}"
                 ]
                 .

  CONSTDEF
              =   COLORCONSTDEF
                | MAGCONSTDEF
                | UINTCONSTDEF
                .

  COLORCONSTDEF
              = (.
                  std::string      name;
                  StyleConstantRef constant;
                  Color            color;
                .)
                "COLOR"
                IDENT<name>
                "="
                COLOR<color>
                (.
                  if (state) {
                    constant=config.GetConstantByName(name);

                    if (constant) {
                      std::string e="Constant already defined";

                      SemErr(e.c_str());
                    }

                    if (!errors->hasErrors) {
                      config.AddConstant(name,std::make_shared<StyleConstantColor>(color));
                    }
                  }
                .)
                .

  MAGCONSTDEF
              = (.
                  std::string      name;
                  StyleConstantRef constant;
                  Magnification    magnification;
                .)
                "MAG"
                IDENT<name>
                "="
                MAG<magnification>
                (.
                  if (state) {
                    constant=config.GetConstantByName(name);

                    if (constant) {
                      std::string e="Constant already defined";

                      SemErr(e.c_str());
                    }

                    if (!errors->hasErrors) {
                      config.AddConstant(name,std::make_shared<StyleConstantMag>(magnification));
                    }
                  }
                .)
                .

  UINTCONSTDEF
              = (.
                  std::string      name;
                  StyleConstantRef constant;
                  size_t           value;
                .)
                "UINT"
                IDENT<name>
                "="
                UINT<value>
                (.
                  if (state) {
                    constant=config.GetConstantByName(name);

                    if (constant) {
                      std::string e="Constant already defined";

                      SemErr(e.c_str());
                    }

                    if (!errors->hasErrors) {
                      config.AddConstant(name,std::make_shared<StyleConstantUInt>(value));
                    }
                  }
                .)
                .

  STYLESECTION
              = "STYLE"
                (. StyleFilter filter; .)
                STYLEBLOCK<filter,true>
                .

  STYLEBLOCK<StyleFilter filter, bool state>
              =
                {
                  (
                      STYLE<filter,state>
                    | STYLECONDBLOCK<filter,state>
                  )
                }
                .

  STYLE<StyleFilter filter, bool state>
              = [
                  STYLEFILTER<filter>
                ]
                (
                  (
                    "{"
                    STYLEBLOCK<filter,state>
                    "}"
                  )
                  | STYLEDEF<filter,state>
                )
                .

  STYLECONDBLOCK<StyleFilter filter, bool state>
              =  (.
                    bool newState=state;
                    bool executed=false;
                 .)
                 "IF"
                 IFCOND<newState>
                 "{"
                 (.
                   this->state=state && newState;
                 .)
                 STYLEBLOCK<filter,state && newState>
                 (.
                   this->state=state;
                   executed=newState;
                 .)
                 "}"
                 {
                   "ELIF"
                   IFCOND<newState>
                   "{"
                   (.
                     this->state=!executed && state && newState;
                   .)
                   STYLEBLOCK<filter,!executed && state && newState>
                   (.
                     this->state=state;
                     executed=newState;
                   .)
                   "}"
                 }
                 [
                   "ELSE"
                   "{"
                   (.
                     this->state=!executed && state;
                   .)
                   STYLEBLOCK<filter,!executed && state>
                   (.
                     this->state=state;
                   .)
                   "}"
                 ]
                 .

  STYLEFILTER<StyleFilter& filter>
              = "["
                   [
                     STYLEFILTER_GROUP<filter>
                   ]
                   [
                     STYLEFILTER_FEATURE<filter>
                   ]
                   [
                     STYLEFILTER_PATH<filter>
                   ]
                   [
                     STYLEFILTER_TYPE<filter>
                   ]
                   [
                     STYLEFILTER_MAG<filter>
                   ]
                   [
                     STYLEFILTER_ONEWAY<filter>
                   ]
                   [
                     STYLEFILTER_SIZE<filter>
                   ]
                "]"
                .

  STYLEFILTER_GROUP<StyleFilter& filter>
              = (.
                   TypeInfoSet types;
                   std::string groupName;
                .)
                "GROUP"
                IDENT<groupName>
                (.
                  for (const auto& type : config.GetTypeConfig()->GetTypes()) {
                    if (type->IsInGroup(groupName)) {
                      if (filter.FiltersByType() &&
                          !filter.HasType(type)) {
                        continue;
                      }

                      types.Set(type);
                    }
                  }
                .)
                {
                  (. std::string groupName; .)
                  ","
                  IDENT<groupName>
                  (.
                    for (const auto& type : config.GetTypeConfig()->GetTypes()) {
                      if (types.IsSet(type) &&
                          !type->IsInGroup(groupName)) {
                        types.Remove(type);
                      }
                    }
                  .)
                }

                (. filter.SetTypes(types); .)
                .

  STYLEFILTER_FEATURE<StyleFilter& filter>
              = (.
                  TypeInfoSet types;
                  std::string featureName;
                .)
                "FEATURE"
                IDENT<featureName>
                (.
                  AddFeatureToFilter(filter,
                                     featureName,
                                     types);                  
                .)
                {
                  ","
                  IDENT<featureName>
                  (.
                    AddFeatureToFilter(filter,
                                       featureName,
                                       types);                  
                  .)
                }

                (. filter.SetTypes(types); .)
                .

  STYLEFILTER_PATH<StyleFilter& filter>
              = (.
                  TypeInfoSet types;
                 .)
                "PATH"
                (.
                  for (const auto& type : config.GetTypeConfig()->GetTypes()) {
                    if (type->IsPath()) {
                      if (filter.FiltersByType() &&
                          !filter.HasType(type)) {
                        continue;
                      }

                      types.Set(type);
                    }
                  }

                  filter.SetTypes(types);
                .)
                .

  STYLEFILTER_TYPE<StyleFilter& filter>
              = (.
                  TypeInfoSet types;
                  std::string name;
                .)

                "TYPE"
                IDENT<name>
                (.
                  TypeInfoRef type=config.GetTypeConfig()->GetTypeInfo(name);

                  if (!type) {
                    std::string e="Unknown type '"+name+"'";

                    SemWarning(e.c_str());
                  }
                  else if (filter.FiltersByType() &&
                           !filter.HasType(type)) {
                    std::string e="Type '"+name+"' is not included by parent filter";

                    SemErr(e.c_str());
                  }
                  else {
                    types.Set(type);
                  }
                .)
                {
                  (. std::string name; .)
                  ","
                  IDENT<name>
                  (.
                    TypeInfoRef type=config.GetTypeConfig()->GetTypeInfo(name);

                    if (!type) {
                      std::string e="Unknown type '"+name+"'";

                      SemWarning(e.c_str());
                    }
                    else if (filter.FiltersByType() &&
                             !filter.HasType(type)) {
                      std::string e="Type '"+name+"' is not included by parent filter";

                      SemErr(e.c_str());
                    }
                    else {
                      types.Set(type);
                    }
                  .)
                }

                (. filter.SetTypes(types); .)
                .

  STYLEFILTER_MAG<StyleFilter& filter>
              = "MAG"
                [
                  (. Magnification magnification; .)
                  MAG<magnification>
                  (.
                     size_t level=magnification.GetLevel();

                     if (level<filter.GetMinLevel()) {
                      std::string e="The magnification interval start is not within the parent magnification range";

                      SemErr(e.c_str());
                     }
                     else {
                       filter.SetMinLevel(level);
                     }
                  .)
                ]
                "-"
                [
                  (. Magnification magnification; .)
                  MAG<magnification>
                  (.
                     size_t level=magnification.GetLevel();

                     if (level>filter.GetMaxLevel()) {
                      std::string e="The magnification interval end is not within the parent magnification range";

                      SemErr(e.c_str());
                     }
                     else {
                       filter.SetMaxLevel(level);
                     }
                  .)
                ]
                .

  STYLEFILTER_ONEWAY<StyleFilter& filter>
              = "ONEWAY"
                (.
                  filter.SetOneway(true);
                .)
                .

  STYLEFILTER_SIZE<StyleFilter& filter>
              = (. SizeConditionRef sizeCondition; .)
                "SIZE"
                SIZECONDITION<sizeCondition>
                (. filter.SetSizeCondition(sizeCondition); .)
                .

  SIZECONDITION<SizeConditionRef& condition>
              = (.
                  condition=std::make_shared<SizeCondition>();
                  double widthInMeter;
                .)

                UDOUBLE<widthInMeter> "m"
                (.
                  if (widthInMeter<0.0) {
                   std::string e="Width must be >= 0.0";

                   SemErr(e.c_str());
                  }
                .)

                [
                  [
                    (. double minMM; .)
                    UDOUBLE<minMM> "mm"
                    (. if (widthInMeter>0.0) {
                         condition->SetMinMM(minMM/widthInMeter);
                       }
                    .)
                  ]
                  ":"
                  [
                    (. double minPx; .)
                    UDOUBLE<minPx> "px"
                    (. if (widthInMeter>0.0) {
                         condition->SetMinPx(minPx/widthInMeter);
                        }
                    .)
                  ]
                ]
                "<"
                [
                  [
                    (. double maxMM; .)
                    UDOUBLE<maxMM> "mm"
                    (. if (widthInMeter>0.0) {
                         condition->SetMaxMM(maxMM/widthInMeter);
                       }
                    .)
                  ]
                  ":"
                  [
                    (. double maxPx; .)
                    UDOUBLE<maxPx> "px"
                    (. if (widthInMeter>0.0) {
                         condition->SetMaxPx(maxPx/widthInMeter);
                       }
                    .)
                  ]
                ]
                .

  STYLEDEF<StyleFilter filter, bool state>
              =   NODESTYLEDEF<filter,state>
                | WAYSTYLEDEF<filter,state>
                | AREASTYLEDEF<filter,state>
                .

  NODESTYLEDEF<StyleFilter filter, bool state>
              = SYNC "NODE" "."
                (
                  NODETEXTSTYLE<filter,state>
                | NODEICONSTYLE<filter,state>
                )
                .

  NODETEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "TEXT"
                (.
                  TextPartialStyle style;
                  std::string      slot;
                .)
                [
                  "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                  TEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddNodeTextStyle(filter,style);
                  }
                .)
                .

  NODEICONSTYLE<StyleFilter filter, bool state>
              = SYNC "ICON"
                (.
                  IconPartialStyle style;
                .)
                SYNC "{"
                {
                  ICONSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddNodeIconStyle(filter,style);
                  }
                .)
                .

  WAYSTYLEDEF<StyleFilter filter, bool state>
              = SYNC "WAY"
                (
                  WAYSTYLE<filter,state>
                | "."
                  (
                     WAYPATHTEXTSTYLE<filter,state>
                  |  WAYPATHSYMBOLSTYLE<filter,state>
                  |  WAYSHIELDSTYLE<filter,state>
                  )
                )
                .

  WAYSTYLE<StyleFilter filter, bool state>
              = (.
                  LinePartialStyle style;
                  std::string      slot;
                .)
                [
                  "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                   LINESTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddWayLineStyle(filter,style);
                  }
                .)
                .

  WAYPATHTEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "TEXT"
                (.
                  PathTextPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHTEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddWayPathTextStyle(filter,style);
                  }
                .)
                .

  WAYPATHSYMBOLSTYLE<StyleFilter filter, bool state>
              = SYNC "SYMBOL"
                (.
                  PathSymbolPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHSYMBOLSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddWayPathSymbolStyle(filter,style);
                  }
                .)
                .

  WAYSHIELDSTYLE<StyleFilter filter, bool state>
              = SYNC "SHIELD"
                (.
                  PathShieldPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHSHIELDSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddWayPathShieldStyle(filter,style);
                  }
                .)
                .

  AREASTYLEDEF<StyleFilter filter, bool state>
              = SYNC "AREA"
                (
                  AREASTYLE<filter,state>
                | "."
                  (
                    AREATEXTSTYLE<filter,state>
                  | AREAICONSTYLE<filter,state>
                  | AREABORDERSTYLE<filter,state>
                  | AREABORDERTEXTSTYLE<filter,state>
                  | AREABORDERSYMBOLSTYLE<filter,state>
                  )
                )
                .

  AREASTYLE<StyleFilter filter, bool state>
              = (.
                  FillPartialStyle style;
                .)
                SYNC "{"
                {
                  FILLSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaFillStyle(filter,style);
                  }
                .)
                .


  AREATEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "TEXT"
                (.
                  TextPartialStyle style;
                  std::string      slot;
                .)
                [
                  "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                  TEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaTextStyle(filter,style);
                  }
                .)
                .

  AREAICONSTYLE<StyleFilter filter, bool state>
              = SYNC "ICON"
                (.
                  IconPartialStyle style;
                .)
                SYNC "{"
                {
                  ICONSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaIconStyle(filter,style);
                  }
                .)
                .

  AREABORDERSTYLE<StyleFilter filter, bool state>
              = SYNC "BORDER"
                (.
                  BorderPartialStyle style;
                  std::string        slot;
                .)
                [
                  "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                  BORDERSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaBorderStyle(filter,style);
                  }
                .)
                .

  AREABORDERTEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "BORDERTEXT"
                (.
                  PathTextPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHTEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaBorderTextStyle(filter,style);
                  }
                .)
                .

  AREABORDERSYMBOLSTYLE<StyleFilter filter, bool state>
              = SYNC "BORDERSYMBOL"
                (.
                  PathSymbolPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHSYMBOLSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaBorderSymbolStyle(filter,style);
                  }
                .)
                .

  LINESTYLEATTR<LinePartialStyle& style>
              = 
                ATTRIBUTE<style,*LineStyle::GetDescriptor()>
                .

  FILLSTYLEATTR<FillPartialStyle& style>
              =   
                ATTRIBUTE<style,*FillStyle::GetDescriptor()>
                .

  BORDERSTYLEATTR<BorderPartialStyle& style>
              = 
                ATTRIBUTE<style,*BorderStyle::GetDescriptor()>
                .

  TEXTSTYLEATTR<TextPartialStyle& style>
              =
                ATTRIBUTE<style,*TextStyle::GetDescriptor()>
                .

  PATHSHIELDSTYLEATTR<PathShieldPartialStyle& style>
              = 
                ATTRIBUTE<style,*PathShieldStyle::GetDescriptor()>              
                .

  PATHTEXTSTYLEATTR<PathTextPartialStyle& style>
              = 
                ATTRIBUTE<style,*PathTextStyle::GetDescriptor()>
                .

  PATHSYMBOLSTYLEATTR<PathSymbolPartialStyle& style>
              = 
                ATTRIBUTE<style,*PathSymbolStyle::GetDescriptor()>
                .

  ICONSTYLEATTR<IconPartialStyle& style>
              = 
                ATTRIBUTE<style,*IconStyle::GetDescriptor()>
                .

  ATTRIBUTE<PartialStyleBase& style, const StyleDescriptor& descriptor>
              =
                 (.
                   std::string                 attributeName;
                   StyleAttributeDescriptorRef attributeDescriptor;
                 .)
                 (
                   IDENT<attributeName>
                 | "name" (. attributeName="name"; .)  
                 )
                 
                 (.
                   attributeDescriptor=descriptor.GetAttribute(attributeName);
                   
                   if (!attributeDescriptor) {
                     std::string e="'"+attributeName+"' is not a known attribute of the given style";

                     SemErr(e.c_str());
                     
                     attributeDescriptor=std::make_shared<StyleVoidAttributeDescriptor>();
                   }
                  .)
                 ":"
                 ATTRIBUTEVALUE<style,*attributeDescriptor>
                 .

  /*
    We have the following source types (types we actualy parse)
    IDENT,
    STRING,
    COLOR,
    NUMBER,
    CONSTANT
    
    and the following target types (types we should return):
    BOOL,
    STRING,
    COLOR,
    MAGNIFICATION,
    ENUM,
    DISPLAY_SIZE,
    UDISPLAY_SIZE,
    MAP_SIZE,
    UMAP_SIZE,
    DOUBLE,
    UDOUBLE,
    UDOUBLE_ARRAY,
    INT,
    UINT,
    LABEL,
    SYMBOL    

   (in both cases besides "VOID")
  */
  ATTRIBUTEVALUE<PartialStyleBase& style, const StyleAttributeDescriptor& descriptor>
              =
                 (.
                   ValueType              valueType=ValueType::NO_VALUE;
                   bool                   negate=false;
                   std::string            ident;
                   std::string            subIdent;
                   std::string            stringValue;
                   std::string            function;
                   double                 factor;
                   std::string            unit;
                   std::string            number;
                   std::list<std::string> numberList;
                   Color                  color;
                   StyleConstantRef       constant;
                  .)
                  
                 (
                   (
                     IDENT<ident> (. valueType=ValueType::IDENT; .)
                   | "lighten"    (. ident="lighten"; valueType=ValueType::IDENT; .)  
                   | "darken"     (. ident="darken"; valueType=ValueType::IDENT; .)  
                   )
                   [
                     (
                       "("
                       (.
                           valueType=ValueType::COLOR;
                           function=ident;
                        .)
                       (
                         COLOR_VALUE<color>
                       | CONSTANT<constant>
                       )
                       ","
                       UDOUBLE<factor>
                       ")"
                     )
                     |
                     (
                       "."
                       (
                         IDENT<subIdent>
                       | "name" (. subIdent="name"; .)  
                       )
                     )  
                   ]
                 | STRING<stringValue>
                   (. valueType=ValueType::STRING; .)
                 | [
                    "-" (. negate=true; .)
                   ]
                   (
                     number
                     (.
                       number=t->val;
                       valueType=ValueType::NUMBER;
                     .)
                     [
                       (
                         IDENT<unit>
                       | "mm" (. unit="mm"; .)
                       | "m"  (. unit="m"; .)
                       )  
                     ]
                     {
                       ","
                       (
                         number (. numberList.push_back(t->val); .)
                       | double (. numberList.push_back(t->val); .)
                       )
                     }  
                   | double
                     (.
                       number=t->val;
                       valueType=ValueType::NUMBER;
                     .)  
                     [
                       (
                         IDENT<unit>
                       | "mm" (. unit="mm"; .)
                       | "m"  (. unit="m"; .)
                       )  
                     ]
                     {
                       ","
                       (
                         number (. numberList.push_back(t->val); .)
                       | double (. numberList.push_back(t->val); .)
                       )
                     }  
                   )                   
                 | COLOR_VALUE<color>
                   (. valueType=ValueType::COLOR; .)
                 | CONSTANT<constant>
                   (. valueType=ValueType::CONSTANT; .)
                 )
                 
                 (.
                   if (descriptor.GetType()==StyleAttributeType::TYPE_BOOL) {
                     if (valueType==ValueType::IDENT) {
                       if (ident=="true" && subIdent.empty()) {
                         style.SetBoolValue(descriptor.GetAttribute(),true);
                       }
                       else if (ident=="false" && subIdent.empty()) {
                         style.SetBoolValue(descriptor.GetAttribute(),false);
                       }
                       else {
                         std::string e="Attribute '"+descriptor.GetName()+"' requires a boolean value ('true' or 'false')";
                        
                         SemErr(e.c_str());
                       }
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";
                       
                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_STRING) {
                     if (valueType==ValueType::IDENT) {
                       if (subIdent.empty()) {
                         style.SetStringValue(descriptor.GetAttribute(),ident);
                       }
                       else {
                         std::string e="Attribute '"+descriptor.GetName()+"' requires a simple IDENT as value";
                       
                         SemErr(e.c_str());
                       }
                     }
                     else if (valueType==ValueType::STRING) {
                       style.SetStringValue(descriptor.GetAttribute(),stringValue);
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";
                       
                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_COLOR) {
                     if (valueType==ValueType::COLOR) {
                       if (constant) {
                         if (dynamic_cast<StyleConstantColor*>(constant.get())==NULL) {
                           std::string e="Constant is not of type 'COLOR'";

                           SemErr(e.c_str());
                         }
                         else {
                           StyleConstantColor* colorConstant=dynamic_cast<StyleConstantColor*>(constant.get());

                           color=colorConstant->GetColor();
                         }
                       }
                     
                       if (!function.empty()) {
                         if (factor<0.0 && factor>1.0) {
                          std::string e="Factor must be in the range [0..1]";

                           SemErr(e.c_str());
                         }
                       
                         if (function=="lighten") {
                           if (!errors->hasErrors) {
                             style.SetColorValue(descriptor.GetAttribute(),color.Lighten(factor));
                           }
                         }
                         else if (function=="darken") {
                           if (!errors->hasErrors) {
                             style.SetColorValue(descriptor.GetAttribute(),color.Darken(factor));
                           }
                         }
                         else {
                           std::string e="Unknown color function '"+function+"'";

                           SemErr(e.c_str());
                         }
                       }
                       else {                     
                         style.SetColorValue(descriptor.GetAttribute(),color);
                       }
                     }
                     else if (valueType==ValueType::CONSTANT) {
                       if (!constant) {
                         // no code
                       }
                       else if (dynamic_cast<StyleConstantColor*>(constant.get())==NULL) {
                         std::string e="Constant is not of type 'COLOR'";

                         SemErr(e.c_str());
                       }

                       if (!errors->hasErrors) {
                         StyleConstantColor* colorConstant=dynamic_cast<StyleConstantColor*>(constant.get());

                         style.SetColorValue(descriptor.GetAttribute(),colorConstant->GetColor());
                       }
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";
                       
                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_MAGNIFICATION) {
                     if (valueType==ValueType::IDENT) {
                       Magnification magnification;
                       
                       if (subIdent.empty() && magnificationConverter.Convert(ident,magnification)) {
                         style.SetMagnificationValue(descriptor.GetAttribute(),magnification);
                       }
                       else {
                         std::string e="'"+std::string(ident)+"' is not a valid magnification level";

                         SemErr(e.c_str());
                       }
                     }
                     else if (valueType==ValueType::NUMBER) {
                       Magnification magnification;
                       size_t        level;
                       
                       if (StringToNumber(number,level)) {
                         magnification.SetLevel((uint32_t)level);
                       }
                       else {
                         std::string e="Cannot parse number '"+std::string(number)+"'";

                         SemErr(e.c_str());
                       }
                     }
                     else if (valueType==ValueType::CONSTANT) {
                       if (!constant) {
                         // no code
                       }
                       else if (dynamic_cast<StyleConstantMag*>(constant.get())==NULL) {
                         std::string e="Constant is not of type 'MAGNIFICATION'";

                         SemErr(e.c_str());
                       }

                       if (!errors->hasErrors) {
                         StyleConstantMag* uintConstant=dynamic_cast<StyleConstantMag*>(constant.get());

                         style.SetMagnificationValue(descriptor.GetAttribute(),uintConstant->GetMag());
                       }
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";
                       
                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_ENUM) {
                     const StyleEnumAttributeDescriptor& enumDescriptor=dynamic_cast<const StyleEnumAttributeDescriptor&>(descriptor);
                     
                     if (valueType==ValueType::IDENT) {
                       int value=enumDescriptor.GetEnumValue(ident);
                       
                       if (value>=0) {
                         style.SetIntValue(descriptor.GetAttribute(),value);
                       }
                       else {
                         std::string e="'"+ident+"' is not a valid enumeration value for this attribute";
                       
                         SemErr(e.c_str());
                       }
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";
                       
                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_DISPLAY_SIZE) {
                     if (valueType==ValueType::NUMBER) {                     
                       double value;
                       
                       if (unit!="mm") {
                         std::string e="Value must have unit 'mm' and not '"+unit+"'";

                         SemErr(e.c_str());
                       }
                      
                       if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       
                       if (!errors->hasErrors) {
                         if (negate) {
                           value=-value;
                         }
                         style.SetDoubleValue(descriptor.GetAttribute(),value);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_UDISPLAY_SIZE) {
                     if (valueType==ValueType::NUMBER) {                     
                       double value;
                       
                       if (negate) {
                         std::string e="Negative numbers not allowed here";

                         SemErr(e.c_str());
                       }

                       if (unit!="mm") {
                         std::string e="Value must have unit 'mm' and not '"+unit+"'";

                         SemErr(e.c_str());
                       }
                      
                       if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       
                       if (!errors->hasErrors) {
                         style.SetDoubleValue(descriptor.GetAttribute(),value);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_MAP_SIZE) {
                     if (valueType==ValueType::NUMBER) {                     
                       double value;
                       
                       if (unit!="m") {
                         std::string e="Value must have unit 'm' and not '"+unit+"'";

                         SemErr(e.c_str());
                       }
                      
                       if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       
                       if (!errors->hasErrors) {
                         if (negate) {
                           value=-value;
                         }
                         style.SetDoubleValue(descriptor.GetAttribute(),value);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_UMAP_SIZE) {
                     if (valueType==ValueType::NUMBER) {                     
                       double value;
                       
                       if (negate) {
                         std::string e="Negative numbers not allowed here";

                         SemErr(e.c_str());
                       }

                       if (unit!="m") {
                         std::string e="Value must have unit 'm' and not '"+unit+"'";

                         SemErr(e.c_str());
                       }
                      
                       if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       
                       if (!errors->hasErrors) {
                         style.SetDoubleValue(descriptor.GetAttribute(),value);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_DOUBLE) {
                     if (valueType==ValueType::NUMBER) {                     
                       double value;
                       
                       if (!unit.empty()) {
                         std::string e="Value must not have a unit";

                         SemErr(e.c_str());
                       }
                      
                       if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       
                       if (!errors->hasErrors) {
                         if (negate) {
                           value=-value;
                         }
                         style.SetDoubleValue(descriptor.GetAttribute(),value);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_UDOUBLE) {
                     if (valueType==ValueType::NUMBER) {                     
                       double value;
                       
                       if (negate) {
                         std::string e="Negative numbers not allowed here";

                         SemErr(e.c_str());
                       }

                       if (!unit.empty()) {
                         std::string e="Value must not have unit";

                         SemErr(e.c_str());
                       }
                      
                       if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       
                       if (!errors->hasErrors) {
                         style.SetDoubleValue(descriptor.GetAttribute(),value);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_UDOUBLE_ARRAY) {
                     if (valueType==ValueType::NUMBER) {
                       double              value;
                       std::vector<double> valueList(numberList.size()+1);
                       
                       if (negate) {
                         std::string e="Negative numbers not allowed here";

                         SemErr(e.c_str());
                       }

                       if (!unit.empty()) {
                         std::string e="Value must not have unit";

                         SemErr(e.c_str());
                       }
                      
                       if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       
                       valueList.push_back(value);
                       
                       for (const auto number : numberList) {
                         if (!StringToNumber(number,value)) {
                           std::string e="Cannot parse number '"+number+"'";

                           SemErr(e.c_str());
                         }
                         
                         valueList.push_back(value);
                       }
                       
                       if (!errors->hasErrors) {
                         style.SetDoubleArrayValue(descriptor.GetAttribute(),valueList);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_LABEL) {
                     if (!subIdent.empty()) {
                       FeatureRef feature;

                       feature=config.GetTypeConfig()->GetFeature(ident);

                       if (!feature) {
                         std::string e="'"+ident+"' is not a registered feature";

                         SemErr(e.c_str());
                       }
                       else if (!feature->HasLabel()) {
                         std::string e="'"+ident+"' does not support labels";

                         SemErr(e.c_str());
                       }
                       else {
                         size_t labelIndex;

                         if (!feature->GetLabelIndex(subIdent,
                                                     labelIndex)) {
                           std::string e="'"+ident+"' does not have a label named '"+subIdent+"'";

                           SemErr(e.c_str());
                         }
                         else {
                           LabelProviderRef label;
                           
                           label=std::make_shared<DynamicFeatureLabelReader>(*config.GetTypeConfig(),
                                                                             ident,
                                                                             subIdent);
                           style.SetLabelValue(descriptor.GetAttribute(),label);
                         }
                       }
                     }
                     else {
                       LabelProviderRef label;
                       
                       label=config.GetLabelProvider(ident);

                       if (!label) {
                         std::string e="There is no label provider with name '"+ident+"' registered";

                         SemErr(e.c_str());
                       }
                       else {
                         style.SetLabelValue(descriptor.GetAttribute(),label);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_SYMBOL) {
                     if (valueType==ValueType::IDENT) {
                       SymbolRef symbol=config.GetSymbol(ident);

                       if (symbol && subIdent.empty()) {
                         style.SetSymbolValue(descriptor.GetAttribute(),symbol);
                       }
                       else {
                         std::string e="Map symbol '"+ident+"' is not defined";

                         SemErr(e.c_str());
                       }
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";
                       
                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_INT) {                   
                     if (valueType==ValueType::NUMBER) {                     
                       int value;
                       
                       if (!unit.empty()) {
                         std::string e="Vaue must not have a unit";

                         SemErr(e.c_str());
                       }
                      
                       if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       
                       if (!errors->hasErrors) {
                         if (negate) {
                           value=-value;
                         }
                         style.SetIntValue(descriptor.GetAttribute(),value);
                       }
                     }
                     /*else if (valueType==ValueType::CONSTANT) {
                       if (!constant) {
                         // no code
                       }
                       else if (dynamic_cast<StyleConstantInt*>(constant.get())==NULL) {
                         std::string e="Constant is not of type 'INT'";

                         SemErr(e.c_str());
                       }

                       if (!errors->hasErrors) {
                         StyleConstantInt* uintConstant=dynamic_cast<StyleConstantInt*>(constant.get());

                         style.SetIntValue(descriptor.GetAttribute(),intConstant->GetInt());
                       }
                     }*/
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";
                       
                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_UINT) {                   
                     if (valueType==ValueType::NUMBER) {                     
                       size_t value;
                       
                       if (negate) {
                         std::string e="Negative numbers not allowed here";

                         SemErr(e.c_str());
                       }

                       if (!unit.empty()) {
                         std::string e="Vaue must not have a unit";

                         SemErr(e.c_str());
                       }
                      
                       if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       
                       if (!errors->hasErrors) {
                         style.SetUIntValue(descriptor.GetAttribute(),value);
                       }
                     }
                     else if (valueType==ValueType::CONSTANT) {
                       if (!constant) {
                         // no code
                       }
                       else if (dynamic_cast<StyleConstantUInt*>(constant.get())==NULL) {
                         std::string e="Constant is not of type 'UINT'";

                         SemErr(e.c_str());
                       }

                       if (!errors->hasErrors) {
                         StyleConstantUInt* uintConstant=dynamic_cast<StyleConstantUInt*>(constant.get());

                         style.SetUIntValue(descriptor.GetAttribute(),uintConstant->GetUInt());
                       }
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";
                       
                       SemErr(e.c_str());
                     }
                   }
                 .)
                .

  COLOR_VALUE<Color& color>
               =
                color 
                (.
                  std::string c(t->val);

                  if (c.length()!=7 &&
                      c.length()!=9) {
                    std::string e="Illegal color value";
                    
                    SemErr(e.c_str());
                  }

                  if (!errors->hasErrors) {
                    color=osmscout::Color::FromHexString(c);
                  }
                .) 
               . 

  CONSTANT<StyleConstantRef& constant>
               = 
                 (.
                   constant=NULL;
                 .)
                 variable
                 (.
                   constant=config.GetConstantByName(t->val+1);

                   if (!constant) {
                     std::string e=std::string("Constant \"") + t->val + "\" not defined";

                     SemErr(e.c_str());
                   }
                 .)
               . 

  STRING<std::string& value>
              = string
                (.
                  value=Destring(t->val);
                .)
                .

  COLOR<Color& color>
              =  
                (.
                   StyleConstantRef constant;
                   double           factor;
                .)
                ( 
                  "lighten" "(" COLOR<color> "," UDOUBLE<factor> ")"
                  (.
                    if (factor>=0.0 && factor<=1.0) {
                      color=color.Lighten(factor);
                    }
                    else {
                     std::string e="Factor must be in the range [0..1]";

                      SemErr(e.c_str());
                    }
                  .)
                | (. double factor; .)
                  "darken" "(" COLOR<color> "," UDOUBLE<factor> ")"
                  (.
                    if (factor>=0.0 && factor<=1.0) {
                      color=color.Darken(factor);
                    }
                    else {
                     std::string e="Factor must be in the range [0..1]";

                      SemErr(e.c_str());
                    }
                  .)
                | COLOR_VALUE<color>
                | CONSTANT<constant>
                  (.
                    if (!constant) {
                      color=Color::BLACK;
                    }
                    else if (dynamic_cast<StyleConstantColor*>(constant.get())==NULL) {
                      std::string e="Constant is not of type 'COLOR'";

                      SemErr(e.c_str());

                      color=Color::BLACK;
                    }
                    else {
                      StyleConstantColor* colorConstant=dynamic_cast<StyleConstantColor*>(constant.get());

                      color=colorConstant->GetColor();
                    }
                  .)
                )  
                .

  MAG<Magnification& magnification>
              = 
                (
                  (. std::string name; .)
                  IDENT<name>
                  (.
                    if (!magnificationConverter.Convert(name,magnification)) {
                      std::string e="'"+std::string(name)+"' is not a valid magnification level";

                      SemErr(e.c_str());
                    }
                  .)
                )
                |
                (
                  (. size_t level; .)
                  number
                  (.
                    if (!StringToNumber(t->val,level)) {
                      std::string e="Cannot parse number '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                    else {
                      magnification.SetLevel((uint32_t)level);
                    }
                  .)
                )
                |
                (
                  (. StyleConstantRef constant; .)
                  CONSTANT<constant>
                  (.
                    if (!constant) {
                      magnification.SetLevel(0);
                    }
                    else if (dynamic_cast<StyleConstantMag*>(constant.get())==NULL) {
                      std::string e="Variable is not of type 'MAG'";

                      SemErr(e.c_str());
                    }
                    else {
                      StyleConstantMag* magConstant=dynamic_cast<StyleConstantMag*>(constant.get());

                      magnification=magConstant->GetMag();
                    }
                  .)
                )  
              .

  IDENT<std::string& value>
              = ident
                (.
                  value=t->val;
                .)
                .

  BOOL<bool& value>
              = (. std::string ident; .)
                ident
                (.
                  ident=t->val;

                  if (ident=="true") {
                    value=true;
                  }
                  else if (ident=="false") {
                    value=false;
                  }
                  else {
                    std::string e="'"+std::string(t->val)+"' is not a valid boolean value, only 'true' and 'false' are allowed";

                    SemErr(e.c_str());

                    value=false;
                  }
                .)
                .

  UDOUBLE<double& value>
              =   number
                  (.
                    if (!StringToDouble(t->val,value)) {
                      std::string e="Cannot parse double '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                  .)
                | double
                  (.
                    if (!StringToDouble(t->val,value)) {
                      std::string e="Cannot parse double '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                  .)
                .

  DOUBLE<double& value>
              = (. bool negate=false; .)
                [
                  "-" (. negate=true; .)
                ]
                (
                  number
                  (.
                    if (!StringToDouble(t->val,value)) {
                      std::string e="Cannot parse double '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                  .)
                |
                  double
                  (.
                    if (!StringToDouble(t->val,value)) {
                      std::string e="Cannot parse double '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                  .)
                )
                (.
                  if (negate) {
                    value=-value;
                  }
                .)
                .

  UINT<size_t& value>
              = number
                (.
                  if (!StringToNumber(t->val,value)) {
                    std::string e="Cannot parse number '"+std::string(t->val)+"'";

                    SemErr(e.c_str());
                  }
                .)
                | variable
                  (.
                    StyleConstantRef constant=config.GetConstantByName(t->val+1);

                    if (!constant) {
                      std::string e="Constant not defined";

                      SemErr(e.c_str());
                    }
                    else if (dynamic_cast<StyleConstantUInt*>(constant.get())==NULL) {
                      std::string e="Constant is not of type 'UINT'";

                      SemErr(e.c_str());
                    }

                    if (!errors->hasErrors) {
                      StyleConstantUInt* uintConstant=dynamic_cast<StyleConstantUInt*>(constant.get());

                      value=uintConstant->GetUInt();
                    }
                  .)
                .
  IFCOND<bool& state>
              =  (.
                   std::string flag;
                   bool        negate=false;
                 .)
                 ["!" (. negate=true; .)]
                 IDENT<flag>
                 (.
                   if (!config.HasFlag(flag)) {
                     std::string e="Flag '" + flag +"' is unknown, ignoring";

                     SemErr(e.c_str());
                     state=false;
                   }
                   else {
                     state=config.GetFlagByName(flag);
                   }

                   if (negate) {
                     state=!state;
                   }
                 .)
                 .
END OSS.

