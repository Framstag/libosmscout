#include <limits>
#include <list>
#include <sstream>

#include <osmscout/Pixel.h>

#include <osmscout/TypeConfig.h>

#include <osmscout/io/File.h>

#include <osmscout/util/String.h>
#include <osmscout/util/Transformation.h>
#include <osmscout/log/Logger.h>

COMPILER OSS

std::string                           filename;
StyleConfig&                          config;
MagnificationConverter                magnificationConverter;
bool                                  state;

enum class ValueType
{
  NO_VALUE,
  IDENT,
  STRING,
  COLOR,
  NUMBER,
  CONSTANT
};

std::string Destring(const char* str)
{
  std::string result(str);

  if (result.length()>=2 &&
      result[0]=='"' &&
      result[result.length()-1]=='"') {
    result=result.substr(1,result.length()-2);
  }

  return result;
}

bool StringToDouble(const char* string, double& value)
{
  std::istringstream buffer(string);

  buffer.imbue(std::locale::classic());

  buffer >> value;

  return !buffer.fail() && !buffer.bad() && buffer.eof();
}

size_t GetHexDigitValue(char c)
{
  if (c>='0' && c<='9') {
    return c-'0';
  }
  else if (c>='a' && c<='f') {
    return 10+(c-'a');
  }

  assert(false);
  return 0;
}

void AddFeatureToFilter(StyleFilter& filter,
                        const std::string& featureName,
                        const std::string& flagName,
                        TypeInfoSet& resultTypes)
{
  FeatureRef feature=config.GetTypeConfig()->GetFeature(featureName);

  if (!feature) {
    std::string e="Unknown feature '"+featureName+"'";

    SemErr(e.c_str());
    return;
  }

  size_t flagIndex=std::numeric_limits<size_t>::max();

  if (!flagName.empty() &&
      !feature->GetFlagIndex(flagName,
                             flagIndex)) {
    std::string e="Unknown feature flag '"+featureName+"."+flagName+"'";

    SemErr(e.c_str());
    return;
  }

  for (const auto& type : config.GetTypeConfig()->GetTypes()) {
    if (type->HasFeature(featureName)) {
      if (!filter.FiltersByType() ||
          filter.HasType(type)) {
        // Add type only if the filter either has no types or
        // if the type is already filtered
        resultTypes.Set(type);
      }
    }
  }

  if (!resultTypes.Empty()) {
    size_t featureFilterIndex=config.GetFeatureFilterIndex(*feature);

    filter.AddFeature(featureFilterIndex,
                      flagIndex);
  }
}

CHARACTERS
  letter     = 'a'..'z' + 'A'..'Z'.
  digit      = '0'..'9'.
  hexdigit   = 'a'..'f' + '0'..'9'.
  eol        = '\n'.
  stringchar = ANY - '"'.
  quotchar   = ANY.

TOKENS
  ident      = ('_' | letter) {letter | digit | '_'}.
  number     = digit {digit}.
  double     = digit {digit} '.' digit {digit}.
  color      = "#" hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit [hexdigit hexdigit].
  variable   = "@" ('_' | letter) {letter | digit | '_'}.
  string     = '"' {stringchar | '\\' quotchar} '"'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO eol

IGNORE ' ' + '\t' + '\r' + '\n'

PRODUCTIONS
  OSS         = SYNC "OSS"
                (. state=true; .)
                [IMPORTS]
                {
                  FLAGSECTION
                }
                [IMPORTS]
                [
                  WAYORDER
                ]
                [IMPORTS]
                {
                  CONSTSECTION
                }
                [IMPORTS]
                {
                  SYMBOLSECTION
                }
                [IMPORTS]
                {
                  STYLESECTION
                }
                [IMPORTS]
                "END"
                .

  IMPORTS = IMPORT
            {
              IMPORT
            }
            .

  IMPORT = SYNC "MODULE"
           (. std::string moduleName; .)
           STRING<moduleName>
           (.
             std::string directory=osmscout::GetDirectory(filename);

             std::string moduleFileName;

             if (!directory.empty()) {
               moduleFileName=osmscout::AppendFileToDir(directory,moduleName)+".oss";
             }
             else {
               moduleFileName=moduleName+".ost";
             }

             bool success=config.Load(moduleFileName,
                                      colorPostprocessor,
                                      true,
                                      errors->log);

             if (!success) {
               std::string e="Cannot load module '"+moduleFileName+"'";

               SemErr(e.c_str());
             }
           .)
           .

  FLAGSECTION = SYNC "FLAG"
                FLAGBLOCK<true>
                .

  FLAGBLOCK<bool state>
              = {
                    FLAGDEF
                  | FLAGCONDBLOCK<state>
                }
                .

  FLAGCONDBLOCK<bool state>
              =  (.
                   bool newState=state;
                   bool executed=false;
                 .)
                 "IF"
                 IFCOND<newState>
                 "{"
                 (.
                   this->state=state && newState;
                 .)
                 FLAGBLOCK<state && newState>
                 (.
                   this->state=state;
                   executed=newState;
                 .)
                 "}"
                 {
                   "ELIF"
                   IFCOND<newState>
                   "{"
                   (.
                     this->state=!executed && state && newState;
                   .)
                   FLAGBLOCK<!executed && state && newState>
                   (.
                     this->state=state;
                     executed=newState;
                   .)
                   "}"
                 }
                 [
                   "ELSE"
                   "{"
                   (.
                     this->state=!executed && state;
                   .)
                   FLAGBLOCK<!executed && state>
                   (.
                     this->state=state;
                   .)
                   "}"
                 ]
                 .

  FLAGDEF     = (.
                  std::string name;
                  bool        value;
                .)
                IDENT<name>
                "="
                BOOL<value>
                (.
                  if (state) {
                    if (!config.HasFlag(name)) {
                      config.AddFlag(name,value);
                    }
                  }
                .)
                ";"
                .

  WAYORDER    = SYNC "ORDER" "WAYS"
                (. size_t priority=1;.)
                {
                  WAYGROUP<priority>
                  (. priority++;.)
                }
                .

  WAYGROUP<size_t priority>
              = SYNC "GROUP"
                [
                  (.
                     std::string wayTypeName;
                     TypeInfoRef wayType;
                  .)
                  IDENT<wayTypeName>
                  (.
                      wayType=config.GetTypeConfig()->GetTypeInfo(wayTypeName);

                      if (!wayType) {
                        std::string e="Unknown way type '"+wayTypeName+"'";
                        SemWarning(e.c_str());
                      }
                      else if (!wayType->CanBeWay()) {
                        std::string e="Tyype '"+wayTypeName+"' is not a way type";
                        SemErr(e.c_str());
                      }
                      else {
                        config.SetWayPrio(wayType,
                                          priority);
                      }
                  .)
                ]
                {
                  (.
                     std::string wayTypeName;
                     TypeInfoRef wayType;
                  .)
                  ","
                  IDENT<wayTypeName>
                  (.
                      wayType=config.GetTypeConfig()->GetTypeInfo(wayTypeName);

                      if (!wayType) {
                        std::string e="Unknown way type '"+wayTypeName+"'";
                        SemWarning(e.c_str());
                      }
                      else if (!wayType->CanBeWay()) {
                        std::string e="Tyype '"+wayTypeName+"' is not a way type";
                        SemErr(e.c_str());
                      }
                      else {
                        config.SetWayPrio(wayType,
                                          priority);
                      }
                  .)
                }
                .

  SYMBOLSECTION
              = SYNC "SYMBOL"
                (.
                  Symbol::ProjectionMode projectionMode=Symbol::ProjectionMode::MAP;
                  std::string name;
                .)
                [
                  "GROUND" (. projectionMode=Symbol::ProjectionMode::GROUND; .)
                ]
                IDENT<name>
                (.
                  SymbolRef symbol=std::make_shared<Symbol>(name,
                                                            projectionMode);
                .)
                {
                  POLYGON<*symbol>
                | RECTANGLE<*symbol>
                | CIRCLE<*symbol>
                }
                (.
                  if (!config.RegisterSymbol(symbol)) {
                    std::string e="Map symbol '"+symbol->GetName()+"' is already defined";
                    SemErr(e.c_str());
                  }
                .)
                .

  AREAFILLSYMSTYLE<FillPartialStyle& fillStyle>
              = SYNC "{"
                {
                  FILLSTYLEATTR<fillStyle> WEAK ";"
                }
                "}"
                .

  AREABORDERSYMSTYLE<BorderPartialStyle& borderStyle>
              = SYNC "BORDER" "{"
                {
                  BORDERSTYLEATTR<borderStyle> WEAK ";"
                }
                "}"
                .

  AREASYMBOLSTYLE<FillPartialStyle& fillStyle, BorderPartialStyle& borderStyle>
              = SYNC "{"
                {
                  SYNC "AREA"
                  (
                    AREAFILLSYMSTYLE<fillStyle>
                  | "."
                    (
                      AREABORDERSYMSTYLE<borderStyle>
                    )
                  )
                }
                SYNC "}"
                .

  POLYGON<Symbol& symbol>
              = SYNC "POLYGON"
                (.
                  StyleFilter         filter;
                  FillPartialStyle    fillStyle;
                  BorderPartialStyle  borderStyle;
                  PolygonPrimitiveRef polygon;
                  Vertex2D            coord;
                .)

                (.
                  polygon=std::make_shared<PolygonPrimitive>(fillStyle.style,
                                                             borderStyle.style);
                .)

                COORD<coord>   (. polygon->AddCoord(coord); .)
                COORD<coord>   (. polygon->AddCoord(coord); .)
                {
                  COORD<coord> (. polygon->AddCoord(coord); .)
                }
                AREASYMBOLSTYLE<fillStyle,borderStyle>
                (. symbol.AddPrimitive(polygon); .)
                .

  RECTANGLE<Symbol& symbol>
              = SYNC "RECTANGLE"
                (.
                  StyleFilter        filter;
                  FillPartialStyle   fillStyle;
                  BorderPartialStyle borderStyle;
                  Vertex2D           topLeft;
                  double             width;
                  double             height;
                .)
                COORD<topLeft>
                UDOUBLE<width>
                "x"
                UDOUBLE<height>

                AREASYMBOLSTYLE<fillStyle,borderStyle>
                (.
                  symbol.AddPrimitive(std::make_shared<RectanglePrimitive>(topLeft,
                                                                           width,height,
                                                                           fillStyle.style,
                                                                           borderStyle.style));
                .)
                .

  CIRCLE<Symbol& symbol>
              = SYNC "CIRCLE"
                (.
                  StyleFilter                   filter;
                  FillPartialStyle              fillStyle;
                  BorderPartialStyle            borderStyle;
                  Vertex2D                      center;
                  double                        radius;
                .)
                COORD<center>
                UDOUBLE<radius>
                AREASYMBOLSTYLE<fillStyle,borderStyle>
                (.
                  symbol.AddPrimitive(std::make_shared<CirclePrimitive>(center,
                                                                        radius,
                                                                        fillStyle.style,
                                                                        borderStyle.style));
                .)
                .

  COORD<Vertex2D& coord>
              = (.
                  double x;
                  double y;
                .)
                DOUBLE<x>
                 ","
                DOUBLE<y>
                (. coord=Vertex2D(x,y); .)
                .

  CONSTSECTION
              = SYNC "CONST"
                CONSTBLOCK<true>
                .

  CONSTBLOCK<bool state>
              = {
                    CONSTCONDBLOCK<state>
                  | CONSTDEF ";"
                }
                .

  CONSTCONDBLOCK<bool state>
              =  (.
                   bool newState=state;
                   bool executed=false;
                 .)
                 "IF"
                 IFCOND<newState>
                 "{"
                 (.
                   this->state=state && newState;
                 .)
                 CONSTBLOCK<state && newState>
                 (.
                   this->state=state;
                   executed=newState;
                 .)
                 "}"
                 {
                   "ELIF"
                   IFCOND<newState>
                   "{"
                   (.
                     this->state=!executed && state && newState;
                   .)
                   CONSTBLOCK<!executed && state && newState>
                   (.
                     this->state=state;
                     executed=newState;
                   .)
                   "}"
                 }
                 [
                   "ELSE"
                   "{"
                   (.
                     this->state=!executed && state;
                   .)
                   CONSTBLOCK<!executed && state>
                   (.
                     this->state=state;
                   .)
                   "}"
                 ]
                 .

  CONSTDEF
              =   COLORCONSTDEF
                | MAGCONSTDEF
                | UINTCONSTDEF
                | WIDTHCONSTDEF
                .

  COLORCONSTDEF
              = (.
                  std::string      name;
                  StyleConstantRef constant;
                  Color            color;
                .)
                "COLOR"
                IDENT<name>
                "="
                COLOR<color>
                (.
                  if (state) {
                    constant=config.GetConstantByName(name);

                    if (constant) {
                      std::string e="Constant already defined";

                      SemErr(e.c_str());
                    }
                    else {
                      config.AddConstant(name,std::make_shared<StyleConstantColor>(color));
                    }
                  }
                .)
                .

  MAGCONSTDEF
              = (.
                  std::string      name;
                  StyleConstantRef constant;
                  Magnification    magnification;
                .)
                "MAG"
                IDENT<name>
                "="
                MAG<magnification>
                (.
                  if (state) {
                    constant=config.GetConstantByName(name);

                    if (constant) {
                      std::string e="Constant already defined";

                      SemErr(e.c_str());
                    }
                    else {
                      config.AddConstant(name,std::make_shared<StyleConstantMag>(magnification));
                    }
                  }
                .)
                .

  UINTCONSTDEF
              = (.
                  std::string      name;
                  StyleConstantRef constant;
                  size_t           value;
                .)
                "UINT"
                IDENT<name>
                "="
                UINT<value>
                (.
                  if (state) {
                    constant=config.GetConstantByName(name);

                    if (constant) {
                      std::string e="Constant already defined";

                      SemErr(e.c_str());
                    }
                    else {
                      config.AddConstant(name,std::make_shared<StyleConstantUInt>(value));
                    }
                  }
                .)
                .

  WIDTHCONSTDEF
              = (.
                  std::string              name;
                  StyleConstantRef         constant;
                  double                   width;
                  std::string              unitValue;
                .)
                "WIDTH"
                IDENT<name>
                "="
                DOUBLE<width>
                (
                  IDENT<unitValue>
                | "mm" (. unitValue="mm"; .)
                | "m"  (. unitValue="m"; .)
                )
                (.
                  if (state) {
                    constant=config.GetConstantByName(name);

                    if (constant) {
                      std::string e="Constant already defined";

                      SemErr(e.c_str());
                    }
                    else {
                      if (unitValue=="mm") {
                        config.AddConstant(name,std::make_shared<StyleConstantWidth>(width,StyleConstantWidth::Unit::mm));
                      }
                      else if (unitValue=="m") {
                        config.AddConstant(name,std::make_shared<StyleConstantWidth>(width,StyleConstantWidth::Unit::m));
                      }
                      else {
                        std::string e="Unsupported unit '"+unitValue+"'";
                        SemErr(e.c_str());
                      }
                    }
                  }
                .)
                .

  STYLESECTION
              = "STYLE"
                (. StyleFilter filter; .)
                STYLEBLOCK<filter,true>
                .

  STYLEBLOCK<StyleFilter filter, bool state>
              =
                {
                  (
                      STYLE<filter,state>
                    | STYLECONDBLOCK<filter,state>
                  )
                }
                .

  STYLE<StyleFilter filter, bool state>
              = [
                  STYLEFILTER<filter>
                ]
                (
                  (
                    "{"
                    STYLEBLOCK<filter,state>
                    "}"
                  )
                  | STYLEDEF<filter,state>
                )
                .

  STYLECONDBLOCK<StyleFilter filter, bool state>
              =  (.
                    bool newState=state;
                    bool executed=false;
                 .)
                 "IF"
                 IFCOND<newState>
                 "{"
                 (.
                   this->state=state && newState;
                 .)
                 STYLEBLOCK<filter,state && newState>
                 (.
                   this->state=state;
                   executed=newState;
                 .)
                 "}"
                 {
                   "ELIF"
                   IFCOND<newState>
                   "{"
                   (.
                     this->state=!executed && state && newState;
                   .)
                   STYLEBLOCK<filter,!executed && state && newState>
                   (.
                     this->state=state;
                     executed=newState;
                   .)
                   "}"
                 }
                 [
                   "ELSE"
                   "{"
                   (.
                     this->state=!executed && state;
                   .)
                   STYLEBLOCK<filter,!executed && state>
                   (.
                     this->state=state;
                   .)
                   "}"
                 ]
                 .

  STYLEFILTER<StyleFilter& filter>
              = "["
                   [
                     STYLEFILTER_GROUP<filter>
                   ]
                   [
                     STYLEFILTER_FEATURE<filter>
                   ]
                   [
                     STYLEFILTER_PATH<filter>
                   ]
                   [
                     STYLEFILTER_TYPE<filter>
                   ]
                   [
                     STYLEFILTER_MAG<filter>
                   ]
                   [
                     STYLEFILTER_ONEWAY<filter>
                   ]
                   [
                     STYLEFILTER_SIZE<filter>
                   ]
                "]"
                .

  STYLEFILTER_GROUP<StyleFilter& filter>
              = (.
                   TypeInfoSet types;
                   std::string groupName;
                .)
                "GROUP"
                IDENT<groupName>
                (.
                  for (const auto& type : config.GetTypeConfig()->GetTypes()) {
                    if (type->IsInGroup(groupName)) {
                      if (filter.FiltersByType() &&
                          !filter.HasType(type)) {
                        continue;
                      }

                      types.Set(type);
                    }
                  }
                .)
                {
                  (. std::string groupName; .)
                  ","
                  IDENT<groupName>
                  (.
                    for (const auto& type : config.GetTypeConfig()->GetTypes()) {
                      if (types.IsSet(type) &&
                          !type->IsInGroup(groupName)) {
                        types.Remove(type);
                      }
                    }
                  .)
                }

                (. filter.SetTypes(types); .)
                .

  STYLEFILTER_FEATURE<StyleFilter& filter>
              = (.
                  TypeInfoSet types;
                .)
                "FEATURE"
                STYLEFILTER_FEATURE_ENTRY<filter,types>
                {
                  ","
                  STYLEFILTER_FEATURE_ENTRY<filter,types>
                }

                (. filter.SetTypes(types); .)
                .

  STYLEFILTER_FEATURE_ENTRY<StyleFilter& filter, TypeInfoSet& types>
              = (.
                  std::string featureName;
                  std::string flagName;
                .)
                IDENT<featureName>
                [
                  "."
                  IDENT<flagName>
                ]
                (.
                  AddFeatureToFilter(filter,
                                     featureName,
                                     flagName,
                                     types);
                .)
                .

  STYLEFILTER_PATH<StyleFilter& filter>
              = (.
                  TypeInfoSet types;
                 .)
                "PATH"
                (.
                  for (const auto& type : config.GetTypeConfig()->GetTypes()) {
                    if (type->IsPath()) {
                      if (filter.FiltersByType() &&
                          !filter.HasType(type)) {
                        continue;
                      }

                      types.Set(type);
                    }
                  }

                  filter.SetTypes(types);
                .)
                .

  STYLEFILTER_TYPE<StyleFilter& filter>
              = (.
                  TypeInfoSet types;
                  std::string name;
                .)

                "TYPE"
                IDENT<name>
                (.
                  TypeInfoRef type=config.GetTypeConfig()->GetTypeInfo(name);

                  if (!type) {
                    std::string e="Unknown type '"+name+"'";

                    SemWarning(e.c_str());
                  }
                  else if (filter.FiltersByType() &&
                           !filter.HasType(type)) {
                    std::string e="Type '"+name+"' is not included by parent filter";

                    SemErr(e.c_str());
                  }
                  else {
                    types.Set(type);
                  }
                .)
                {
                  (. std::string name; .)
                  ","
                  IDENT<name>
                  (.
                    TypeInfoRef type=config.GetTypeConfig()->GetTypeInfo(name);

                    if (!type) {
                      std::string e="Unknown type '"+name+"'";

                      SemWarning(e.c_str());
                    }
                    else if (filter.FiltersByType() &&
                             !filter.HasType(type)) {
                      std::string e="Type '"+name+"' is not included by parent filter";

                      SemErr(e.c_str());
                    }
                    else {
                      types.Set(type);
                    }
                  .)
                }

                (. filter.SetTypes(types); .)
                .

  STYLEFILTER_MAG<StyleFilter& filter>
              = "MAG"
                [
                  (. Magnification magnification; .)
                  MAG<magnification>
                  (.
                     size_t level=magnification.GetLevel();

                     if (level<filter.GetMinLevel()) {
                      std::string e="The magnification interval start is not within the parent magnification range";

                      SemErr(e.c_str());
                     }
                     else {
                       filter.SetMinLevel(level);
                     }
                  .)
                ]
                "-"
                [
                  (. Magnification magnification; .)
                  MAG<magnification>
                  (.
                     size_t level=magnification.GetLevel();

                     if (level>filter.GetMaxLevel()) {
                      std::string e="The magnification interval end is not within the parent magnification range";

                      SemErr(e.c_str());
                     }
                     else {
                       filter.SetMaxLevel(level);
                     }
                  .)
                ]
                .

  STYLEFILTER_ONEWAY<StyleFilter& filter>
              = "ONEWAY"
                (.
                  filter.SetOneway(true);
                .)
                .

  STYLEFILTER_SIZE<StyleFilter& filter>
              = (. SizeConditionRef sizeCondition; .)
                "SIZE"
                SIZECONDITION<sizeCondition>
                (. filter.SetSizeCondition(sizeCondition); .)
                .

  SIZECONDITION<SizeConditionRef& condition>
              = (.
                  double            widthInMeter;
                  StyleConstantRef constant;

                  condition=std::make_shared<SizeCondition>();
                .)

                UMAP<widthInMeter>

                [
                  [
                    (. double minMM; .)
                    UDOUBLE<minMM> "mm"
                    (. if (widthInMeter>0.0) {
                         condition->SetMinMM(minMM/widthInMeter);
                       }
                    .)
                  ]
                  ":"
                  [
                    (. double minPx; .)
                    UDOUBLE<minPx> "px"
                    (. if (widthInMeter>0.0) {
                         condition->SetMinPx(minPx/widthInMeter);
                        }
                    .)
                  ]
                ]
                "<"
                [
                  [
                    (. double maxMM; .)
                    UDOUBLE<maxMM> "mm"
                    (. if (widthInMeter>0.0) {
                         condition->SetMaxMM(maxMM/widthInMeter);
                       }
                    .)
                  ]
                  ":"
                  [
                    (. double maxPx; .)
                    UDOUBLE<maxPx> "px"
                    (. if (widthInMeter>0.0) {
                         condition->SetMaxPx(maxPx/widthInMeter);
                       }
                    .)
                  ]
                ]
                .

  STYLEDEF<StyleFilter filter, bool state>
              =   NODESTYLEDEF<filter,state>
                | WAYSTYLEDEF<filter,state>
                | AREASTYLEDEF<filter,state>
                | ROUTESTYLEDEF<filter,state>
                .

  NODESTYLEDEF<StyleFilter filter, bool state>
              = SYNC "NODE" "."
                (
                  NODETEXTSTYLE<filter,state>
                | NODEICONSTYLE<filter,state>
                )
                .

  NODETEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "TEXT"
                (.
                  TextPartialStyle style;
                  std::string      slot;
                .)
                [
                  "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                  TEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddNodeTextStyle(filter,style);
                  }
                .)
                .

  NODEICONSTYLE<StyleFilter filter, bool state>
              = SYNC "ICON"
                (.
                  IconPartialStyle style;
                .)
                SYNC "{"
                {
                  ICONSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddNodeIconStyle(filter,style);
                  }
                .)
                .

  WAYSTYLEDEF<StyleFilter filter, bool state>
              = SYNC "WAY"
                (
                  WAYSTYLE<filter,state>
                | "."
                  (
                     WAYPATHTEXTSTYLE<filter,state>
                  |  WAYPATHSYMBOLSTYLE<filter,state>
                  |  WAYSHIELDSTYLE<filter,state>
                  )
                )
                .

  WAYSTYLE<StyleFilter filter, bool state>
              = (.
                  LinePartialStyle style;
                  std::string      slot;
                .)
                [
                  "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                   LINESTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddWayLineStyle(filter,style);
                  }
                .)
                .

  ROUTEPATHTEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "TEXT"
                (.
                  PathTextPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHTEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddRoutePathTextStyle(filter,style);
                  }
                .)
                .

  WAYPATHTEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "TEXT"
                (.
                  PathTextPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHTEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddWayPathTextStyle(filter,style);
                  }
                .)
                .

  WAYPATHSYMBOLSTYLE<StyleFilter filter, bool state>
              = SYNC "SYMBOL"
                (.
                  PathSymbolPartialStyle style;
                  std::string      slot;
                .)
                [
                "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                  PATHSYMBOLSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddWayPathSymbolStyle(filter,style);
                  }
                .)
                .

  WAYSHIELDSTYLE<StyleFilter filter, bool state>
              = SYNC "SHIELD"
                (.
                  PathShieldPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHSHIELDSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddWayPathShieldStyle(filter,style);
                  }
                .)
                .

  AREASTYLEDEF<StyleFilter filter, bool state>
              = SYNC "AREA"
                (
                  AREASTYLE<filter,state>
                | "."
                  (
                    AREATEXTSTYLE<filter,state>
                  | AREAICONSTYLE<filter,state>
                  | AREABORDERSTYLE<filter,state>
                  | AREABORDERTEXTSTYLE<filter,state>
                  | AREABORDERSYMBOLSTYLE<filter,state>
                  )
                )
                .

  AREASTYLE<StyleFilter filter, bool state>
              = (.
                  FillPartialStyle style;
                .)
                SYNC "{"
                {
                  FILLSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaFillStyle(filter,style);
                  }
                .)
                .


  AREATEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "TEXT"
                (.
                  TextPartialStyle style;
                  std::string      slot;
                .)
                [
                  "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                  TEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaTextStyle(filter,style);
                  }
                .)
                .

  AREAICONSTYLE<StyleFilter filter, bool state>
              = SYNC "ICON"
                (.
                  IconPartialStyle style;
                .)
                SYNC "{"
                {
                  ICONSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaIconStyle(filter,style);
                  }
                .)
                .

  AREABORDERSTYLE<StyleFilter filter, bool state>
              = SYNC "BORDER"
                (.
                  BorderPartialStyle style;
                  std::string        slot;
                .)
                [
                  "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                  BORDERSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaBorderStyle(filter,style);
                  }
                .)
                .

  AREABORDERTEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "BORDERTEXT"
                (.
                  PathTextPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHTEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaBorderTextStyle(filter,style);
                  }
                .)
                .

  AREABORDERSYMBOLSTYLE<StyleFilter filter, bool state>
              = SYNC "BORDERSYMBOL"
                (.
                  PathSymbolPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHSYMBOLSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaBorderSymbolStyle(filter,style);
                  }
                .)
                .

  ROUTESTYLEDEF<StyleFilter filter, bool state>
                = SYNC "ROUTE"
                (
                  ROUTESTYLE<filter,state>
                | "."
                  (
                    ROUTEPATHTEXTSTYLE<filter,state>
                  )
                )
                .

  ROUTESTYLE<StyleFilter filter, bool state>
                = (.
                    LinePartialStyle style;
                    std::string      slot;
                .)
                SYNC "{"
                {
                  LINESTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddRouteLineStyle(filter,style);
                  }
                .)
                .

  LINESTYLEATTR<LinePartialStyle& style>
              =
                ATTRIBUTE<style,*LineStyle::GetDescriptor()>
                .

  FILLSTYLEATTR<FillPartialStyle& style>
              =
                ATTRIBUTE<style,*FillStyle::GetDescriptor()>
                .

  BORDERSTYLEATTR<BorderPartialStyle& style>
              =
                ATTRIBUTE<style,*BorderStyle::GetDescriptor()>
                .

  TEXTSTYLEATTR<TextPartialStyle& style>
              =
                ATTRIBUTE<style,*TextStyle::GetDescriptor()>
                .

  PATHSHIELDSTYLEATTR<PathShieldPartialStyle& style>
              =
                ATTRIBUTE<style,*PathShieldStyle::GetDescriptor()>
                .

  PATHTEXTSTYLEATTR<PathTextPartialStyle& style>
              =
                ATTRIBUTE<style,*PathTextStyle::GetDescriptor()>
                .

  PATHSYMBOLSTYLEATTR<PathSymbolPartialStyle& style>
              =
                ATTRIBUTE<style,*PathSymbolStyle::GetDescriptor()>
                .

  ICONSTYLEATTR<IconPartialStyle& style>
              =
                ATTRIBUTE<style,*IconStyle::GetDescriptor()>
                .

  ATTRIBUTE<PartialStyleBase& style, const StyleDescriptor& descriptor>
              =
                (.
                  std::string                 attributeName;
                  StyleAttributeDescriptorRef attributeDescriptor;
                .)
                (
                  IDENT<attributeName>
                | "name" (. attributeName="name"; .)
                )

                (.
                  attributeDescriptor=descriptor.GetAttribute(attributeName);

                  if (!attributeDescriptor) {
                    std::string e="'"+attributeName+"' is not a known attribute of the given style";

                    SemErr(e.c_str());

                    attributeDescriptor=std::make_shared<StyleVoidAttributeDescriptor>();
                  }
                 .)
                ":"
                ATTRIBUTEVALUE<style,*attributeDescriptor>
                .

  /*
    We have the following source types (types we actually parse)
    IDENT,
    STRING,
    COLOR,
    NUMBER,
    CONSTANT

    and the following target types (types we should return):
    BOOL,
    STRING,
    COLOR,
    MAGNIFICATION,
    ENUM,
    DISPLAY_SIZE,
    UDISPLAY_SIZE,
    MAP_SIZE,
    UMAP_SIZE,
    DOUBLE,
    UDOUBLE,
    UDOUBLE_ARRAY,
    INT,
    UINT,
    LABEL,
    SYMBOL

   (in both cases besides "VOID")
  */
  ATTRIBUTEVALUE<PartialStyleBase& style, const StyleAttributeDescriptor& descriptor>
              =
                 (.
                   ValueType                valueType=ValueType::NO_VALUE;
                   bool                     negate=false;
                   std::string              ident;
                   std::string              subIdent;
                   std::string              stringValue;
                   std::string              function;
                   double                   factor=-1;
                   std::string              unit;
                   std::string              number;
                   std::vector<std::string> numberList;
                   Color                    color;
                   StyleConstantRef         constant;
                  .)

                 (
                   (
                     IDENT<ident> (. valueType=ValueType::IDENT; .)
                   | "lighten"    (. ident="lighten"; valueType=ValueType::IDENT; .)
                   | "darken"     (. ident="darken"; valueType=ValueType::IDENT; .)
                   | "alpha"      (. ident="alpha"; valueType=ValueType::IDENT; .)
                   )
                   [
                     (
                       "("
                       (.
                           valueType=ValueType::COLOR;
                           function=ident;
                        .)
                       (
                         COLOR_VALUE<color>
                       | CONSTANT<constant>
                       )
                       ","
                       UDOUBLE<factor>
                       ")"
                     )
                     |
                     (
                       "."
                       (
                         IDENT<subIdent>
                       | "name" (. subIdent="name"; .)
                       )
                     )
                   ]
                 | STRING<stringValue>
                   (. valueType=ValueType::STRING; .)
                 | [
                    "-" (. negate=true; .)
                   ]
                   (
                     number
                     (.
                       number=t->val;
                       valueType=ValueType::NUMBER;
                     .)
                     [
                       (
                         IDENT<unit>
                       | "mm" (. unit="mm"; .)
                       | "m"  (. unit="m"; .)
                       )
                     ]
                     {
                       ","
                       (
                         number (. numberList.push_back(t->val); .)
                       | double (. numberList.push_back(t->val); .)
                       )
                     }
                   | double
                     (.
                       number=t->val;
                       valueType=ValueType::NUMBER;
                     .)
                     [
                       (
                         IDENT<unit>
                       | "mm" (. unit="mm"; .)
                       | "m"  (. unit="m"; .)
                       )
                     ]
                     {
                       ","
                       (
                         number (. numberList.push_back(t->val); .)
                       | double (. numberList.push_back(t->val); .)
                       )
                     }
                   )
                 | COLOR_VALUE<color>
                   (. valueType=ValueType::COLOR; .)
                 | CONSTANT<constant>
                   (. valueType=ValueType::CONSTANT; .)
                 )

                 (.
                   if (descriptor.GetType()==StyleAttributeType::TYPE_BOOL) {
                     if (valueType==ValueType::IDENT) {
                       if (ident=="true" && subIdent.empty()) {
                         style.SetBoolValue(descriptor.GetAttribute(),true);
                       }
                       else if (ident=="false" && subIdent.empty()) {
                         style.SetBoolValue(descriptor.GetAttribute(),false);
                       }
                       else {
                         std::string e="Attribute '"+descriptor.GetName()+"' requires a boolean value ('true' or 'false')";

                         SemErr(e.c_str());
                       }
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";

                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_STRING) {
                     if (valueType==ValueType::IDENT) {
                       if (subIdent.empty()) {
                         style.SetStringValue(descriptor.GetAttribute(),ident);
                       }
                       else {
                         std::string e="Attribute '"+descriptor.GetName()+"' requires a simple IDENT as value";

                         SemErr(e.c_str());
                       }
                     }
                     else if (valueType==ValueType::STRING) {
                       style.SetStringValue(descriptor.GetAttribute(),stringValue);
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";

                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_COLOR) {
                     if (valueType==ValueType::COLOR) {
                       if (constant) {
                         StyleConstantColor* colorConstant = dynamic_cast<StyleConstantColor*>(constant.get());
                         if (colorConstant == nullptr) {
                           std::string e="Constant is not of type 'COLOR'";

                           SemErr(e.c_str());
                         }
                         else {
                           color=colorConstant->GetColor();
                         }
                       }

                       if (!errors->hasErrors) {
                         if (!function.empty()) {
                           if (factor<0.0 || factor>1.0) {
                             std::string e="Factor must be in the range [0..1]";

                             SemErr(e.c_str());
                           }
                           else {
                             if (function=="lighten") {
                               style.SetColorValue(descriptor.GetAttribute(),color.Lighten(factor));
                             }
                             else if (function=="darken") {
                               style.SetColorValue(descriptor.GetAttribute(),color.Darken(factor));
                             }
                             else if (function=="alpha") {
                               style.SetColorValue(descriptor.GetAttribute(),color.Alpha(factor));
                             }
                             else {
                               std::string e="Unknown color function '"+function+"'";

                               SemErr(e.c_str());
                             }
                           }
                         }
                         else {
                           style.SetColorValue(descriptor.GetAttribute(),color);
                         }
                       }
                     }
                     else if (valueType==ValueType::CONSTANT) {
                       if (!constant) {
                         // no code
                       }
                       else {
                         StyleConstantColor* colorConstant=dynamic_cast<StyleConstantColor*>(constant.get());
                         if (colorConstant==nullptr) {
                           std::string e="Constant is not of type 'COLOR'";

                           SemErr(e.c_str());
                         }
                         else {
                           style.SetColorValue(descriptor.GetAttribute(),colorConstant->GetColor());
                         }
                       }
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";

                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_MAGNIFICATION) {
                     if (valueType==ValueType::IDENT) {
                       Magnification magnification;

                       if (subIdent.empty() && magnificationConverter.Convert(ident,magnification)) {
                         style.SetMagnificationValue(descriptor.GetAttribute(),magnification);
                       }
                       else {
                         std::string e="'"+std::string(ident)+"' is not a valid magnification level";

                         SemErr(e.c_str());
                       }
                     }
                     else if (valueType==ValueType::NUMBER) {
                       Magnification magnification;
                       uint32_t      level;

                       if (StringToNumber(number,level)) {
                         magnification.SetLevel(osmscout::MagnificationLevel(level));
                       }
                       else {
                         std::string e="Cannot parse number '"+std::string(number)+"'";

                         SemErr(e.c_str());
                       }
                     }
                     else if (valueType==ValueType::CONSTANT) {
                       if (!constant) {
                         // no code
                       }
                       else {
                           StyleConstantMag* uintConstant=dynamic_cast<StyleConstantMag*>(constant.get());
                           if (uintConstant==nullptr) {
                           std::string e="Constant is not of type 'MAGNIFICATION'";

                           SemErr(e.c_str());
                         }
                         else {
                           style.SetMagnificationValue(descriptor.GetAttribute(),uintConstant->GetMag());
                         }
                       }
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";

                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_ENUM) {
                     const StyleEnumAttributeDescriptor& enumDescriptor=dynamic_cast<const StyleEnumAttributeDescriptor&>(descriptor);

                     if (valueType==ValueType::IDENT) {
                       int value=enumDescriptor.GetEnumValue(ident);

                       if (value>=0) {
                         style.SetIntValue(descriptor.GetAttribute(),value);
                       }
                       else {
                         std::string e="'"+ident+"' is not a valid enumeration value for this attribute";

                         SemErr(e.c_str());
                       }
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";

                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_DISPLAY_SIZE) {
                     if (valueType==ValueType::NUMBER) {
                       double value;

                       if (unit!="mm") {
                         std::string e="Value must have unit 'mm' and not '"+unit+"'";

                         SemErr(e.c_str());
                       }
                       else if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       else {
                         if (negate) {
                           value=-value;
                         }
                         style.SetDoubleValue(descriptor.GetAttribute(),value);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_UDISPLAY_SIZE) {
                     if (valueType==ValueType::NUMBER) {
                       double value;

                       if (negate) {
                         std::string e="Negative numbers not allowed here";

                         SemErr(e.c_str());
                       }
                       else if (unit!="mm") {
                         std::string e="Value must have unit 'mm' and not '"+unit+"'";

                         SemErr(e.c_str());
                       }
                       else if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       else {
                         style.SetDoubleValue(descriptor.GetAttribute(),value);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_MAP_SIZE) {
                     if (valueType==ValueType::NUMBER) {
                       double value;

                       if (unit!="m") {
                         std::string e="Value must have unit 'm' and not '"+unit+"'";

                         SemErr(e.c_str());
                       }
                       else if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       else {
                         if (negate) {
                           value=-value;
                         }
                         style.SetDoubleValue(descriptor.GetAttribute(),value);
                       }
                     }
                     else if (valueType==ValueType::CONSTANT) {
                       if (!constant) {
                         // no code
                       }
                       else {
                         StyleConstantWidth* widthConstant=dynamic_cast<StyleConstantWidth*>(constant.get());
                         if (widthConstant==nullptr) {
                           std::string e="Constant is not of type 'WIDTH'";

                           SemErr(e.c_str());
                         }
                         else {
                           if (widthConstant->GetUnit()!=StyleConstantWidth::Unit::m) {
                             std::string e="Constant is not of unit 'm'";

                             SemErr(e.c_str());
                           }
                           else {
                             style.SetDoubleValue(descriptor.GetAttribute(),widthConstant->GetWidth());
                           }
                         }
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_UMAP_SIZE) {
                     if (valueType==ValueType::NUMBER) {
                       double value;

                       if (negate) {
                         std::string e="Width must be >= 0.0";

                         SemErr(e.c_str());
                       }
                       else if (unit!="m") {
                         std::string e="Value must have unit 'm' and not '"+unit+"'";

                         SemErr(e.c_str());
                       }
                       else if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       else {
                         style.SetDoubleValue(descriptor.GetAttribute(),value);
                       }
                     }
                     else if (valueType==ValueType::CONSTANT) {
                       if (!constant) {
                         // no code
                       }
                       else {
                         StyleConstantWidth* widthConstant=dynamic_cast<StyleConstantWidth*>(constant.get());
                         if (widthConstant==nullptr) {
                             std::string e="Constant is not of type 'WIDTH'";

                           SemErr(e.c_str());
                         }
                         else {
                           if (widthConstant->GetUnit()!=StyleConstantWidth::Unit::m) {
                             std::string e="Constant is not of unit 'm'";

                             SemErr(e.c_str());
                           }
                           else if (widthConstant->GetWidth()<0.0) {
                             std::string e="Width must be >= 0.0";

                             SemErr(e.c_str());
                           }
                           else {
                             style.SetDoubleValue(descriptor.GetAttribute(),widthConstant->GetWidth());
                           }
                         }
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_DOUBLE) {
                     if (valueType==ValueType::NUMBER) {
                       double value;

                       if (!unit.empty()) {
                         std::string e="Value must not have a unit";

                         SemErr(e.c_str());
                       }
                       else if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       else {
                         if (negate) {
                           value=-value;
                         }
                         style.SetDoubleValue(descriptor.GetAttribute(),value);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_UDOUBLE) {
                     if (valueType==ValueType::NUMBER) {
                       double value;

                       if (negate) {
                         std::string e="Negative numbers not allowed here";

                         SemErr(e.c_str());
                       }
                       else if (!unit.empty()) {
                         std::string e="Value must not have unit";

                         SemErr(e.c_str());
                       }
                       else if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       else {
                         style.SetDoubleValue(descriptor.GetAttribute(),value);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_UDOUBLE_ARRAY) {
                     if (valueType==ValueType::NUMBER) {
                       double              value;
                       std::vector<double> valueList;
                       valueList.reserve(numberList.size()+1);

                       if (negate) {
                         std::string e="Negative numbers not allowed here";

                         SemErr(e.c_str());
                       }
                       else if (!unit.empty()) {
                         std::string e="Value must not have unit";

                         SemErr(e.c_str());
                       }
                       else if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       else {
                         valueList.push_back(value);

                         bool invalid = false;
                         for (const auto& number : numberList) {
                           if (!StringToNumber(number,value)) {
                             std::string e="Cannot parse number '"+number+"'";

                             SemErr(e.c_str());
                             invalid = true;
                           }
                           else {
                             valueList.push_back(value);
                           }
                         }

                         if (!invalid) {
                           style.SetDoubleArrayValue(descriptor.GetAttribute(),valueList);
                         }
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_LABEL) {
                     if (!subIdent.empty()) {
                       FeatureRef feature;

                       feature=config.GetTypeConfig()->GetFeature(ident);

                       if (!feature) {
                         std::string e="'"+ident+"' is not a registered feature";

                         SemErr(e.c_str());
                       }
                       else if (!feature->HasLabel()) {
                         std::string e="'"+ident+"' does not support labels";

                         SemErr(e.c_str());
                       }
                       else {
                         size_t labelIndex;

                         if (!feature->GetLabelIndex(subIdent,
                                                     labelIndex)) {
                           std::string e="'"+ident+"' does not have a label named '"+subIdent+"'";

                           SemErr(e.c_str());
                         }
                         else {
                           LabelProviderRef label;

                           label=std::make_shared<DynamicFeatureLabelReader>(*config.GetTypeConfig(),
                                                                             ident,
                                                                             subIdent);
                           style.SetLabelValue(descriptor.GetAttribute(),label);
                         }
                       }
                     }
                     else {
                       LabelProviderRef label;

                       label=config.GetLabelProvider(ident);

                       if (!label) {
                         std::string e="There is no label provider with name '"+ident+"' registered";

                         SemErr(e.c_str());
                       }
                       else {
                         style.SetLabelValue(descriptor.GetAttribute(),label);
                       }
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_SYMBOL) {
                     if (valueType==ValueType::IDENT) {
                       SymbolRef symbol=config.GetSymbol(ident);

                       if (symbol && subIdent.empty()) {
                         style.SetSymbolValue(descriptor.GetAttribute(),symbol);
                       }
                       else {
                         std::string e="Map symbol '"+ident+"' is not defined";

                         SemErr(e.c_str());
                       }
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";

                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_INT) {
                     if (valueType==ValueType::NUMBER) {
                       int value;

                       if (!unit.empty()) {
                         std::string e="Vaue must not have a unit";

                         SemErr(e.c_str());
                       }

                       if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       else {
                         if (negate) {
                           value=-value;
                         }
                         style.SetIntValue(descriptor.GetAttribute(),value);
                       }
                     }
                     /*else if (valueType==ValueType::CONSTANT) {
                       if (!constant) {
                         // no code
                       }
                       else {
                         StyleConstantInt* intConstant=dynamic_cast<StyleConstantInt*>(constant.get());
                         if (intConstant==nullptr) {
                           std::string e="Constant is not of type 'INT'";

                           SemErr(e.c_str());
                         }
                         else {
                         style.SetIntValue(descriptor.GetAttribute(),intConstant->GetInt());
                         }
                       }
                     }*/
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";

                       SemErr(e.c_str());
                     }
                   }
                   else if (descriptor.GetType()==StyleAttributeType::TYPE_UINT) {
                     if (valueType==ValueType::NUMBER) {
                       size_t value;

                       if (negate) {
                         std::string e="Negative numbers not allowed here";

                         SemErr(e.c_str());
                       }
                       else if (!unit.empty()) {
                         std::string e="Vaue must not have a unit";

                         SemErr(e.c_str());
                       }
                       else if (!StringToNumber(number,value)) {
                         std::string e="Cannot parse number '"+number+"'";

                         SemErr(e.c_str());
                       }
                       else {
                         style.SetUIntValue(descriptor.GetAttribute(),value);
                       }
                     }
                     else if (valueType==ValueType::CONSTANT) {
                       if (!constant) {
                         // no code
                       }
                       else {
                         StyleConstantUInt* uintConstant=dynamic_cast<StyleConstantUInt*>(constant.get());
                         if (uintConstant==nullptr) {
                           std::string e="Constant is not of type 'UINT'";

                           SemErr(e.c_str());
                         }
                         else {
                           style.SetUIntValue(descriptor.GetAttribute(),uintConstant->GetUInt());
                         }
                       }
                     }
                     else {
                       std::string e="Attribute '"+descriptor.GetName()+"' has incompatible type for value";

                       SemErr(e.c_str());
                     }
                   }
                 .)
                .

  COLOR_VALUE<Color& color>
               =
                color
                (.
                  std::string c(t->val);

                  if (c.length()!=7 &&
                      c.length()!=9) {
                    std::string e="Illegal color value";

                    SemErr(e.c_str());
                  }
                  else {
                    color=PostprocessColor(osmscout::Color::FromHexString(c));
                  }
                .)
               .

  CONSTANT<StyleConstantRef& constant>
               =
                 (.
                   constant=nullptr;
                 .)
                 variable
                 (.
                   constant=config.GetConstantByName(t->val+1);

                   if (!constant) {
                     std::string e=std::string("Constant \"") + t->val + "\" not defined";

                     SemErr(e.c_str());
                   }
                 .)
               .

  STRING<std::string& value>
              = string
                (.
                  value=Destring(t->val);
                .)
                .

  COLOR<Color& color>
              =
                (.
                   StyleConstantRef constant;
                   double           factor;
                .)
                (
                  "lighten" "(" COLOR<color> "," UDOUBLE<factor> ")"
                  (.
                    if (factor>=0.0 && factor<=1.0) {
                      color=PostprocessColor(color.Lighten(factor));
                    }
                    else {
                     std::string e="Factor must be in the range [0..1]";

                      SemErr(e.c_str());
                    }
                  .)
                | (. double factor; .)
                  "darken" "(" COLOR<color> "," UDOUBLE<factor> ")"
                  (.
                    if (factor>=0.0 && factor<=1.0) {
                      color=PostprocessColor(color.Darken(factor));
                    }
                    else {
                     std::string e="Factor must be in the range [0..1]";

                      SemErr(e.c_str());
                    }
                  .)
                | COLOR_VALUE<color>
                  (.
                    color=PostprocessColor(color);
                  .)
                | CONSTANT<constant>
                  (.
                    if (!constant) {
                      color=Color::BLACK;
                    }
                    else {
                      StyleConstantColor* colorConstant=dynamic_cast<StyleConstantColor*>(constant.get());
                      if (colorConstant==nullptr) {
                        std::string e="Constant is not of type 'COLOR'";

                        SemErr(e.c_str());

                        color=Color::BLACK;
                      }
                      else {
                        color=colorConstant->GetColor();
                      }
                    }
                  .)
                )
                .

  MAG<Magnification& magnification>
              =
                (
                  (. std::string name; .)
                  IDENT<name>
                  (.
                    if (!magnificationConverter.Convert(name,magnification)) {
                      std::string e="'"+std::string(name)+"' is not a valid magnification level";

                      SemErr(e.c_str());
                    }
                  .)
                )
                |
                (
                  (. uint32_t level; .)
                  number
                  (.
                    if (!StringToNumber(t->val,level)) {
                      std::string e="Cannot parse number '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                    else {
                      magnification.SetLevel(osmscout::MagnificationLevel(level));
                    }
                  .)
                )
                |
                (
                  (. StyleConstantRef constant; .)
                  CONSTANT<constant>
                  (.
                    if (!constant) {
                      magnification.SetLevel(osmscout::MagnificationLevel(0));
                    }
                    else {
                      StyleConstantMag* magConstant=dynamic_cast<StyleConstantMag*>(constant.get());
                      if (magConstant==nullptr) {
                        std::string e="Variable is not of type 'MAG'";

                        SemErr(e.c_str());
                      }
                      else {
                        magnification=magConstant->GetMag();
                      }
                    }
                  .)
                )
              .

  IDENT<std::string& value>
              = ident
                (.
                  value=t->val;
                .)
                .

  BOOL<bool& value>
              = (. std::string ident; .)
                ident
                (.
                  ident=t->val;

                  if (ident=="true") {
                    value=true;
                  }
                  else if (ident=="false") {
                    value=false;
                  }
                  else {
                    std::string e="'"+std::string(t->val)+"' is not a valid boolean value, only 'true' and 'false' are allowed";

                    SemErr(e.c_str());

                    value=false;
                  }
                .)
                .

  UDOUBLE<double& value>
              =   number
                  (.
                    if (!StringToDouble(t->val,value)) {
                      std::string e="Cannot parse double '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                  .)
                | double
                  (.
                    if (!StringToDouble(t->val,value)) {
                      std::string e="Cannot parse double '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                  .)
                .

  DOUBLE<double& value>
              = (. bool negate=false; .)
                [
                  "-" (. negate=true; .)
                ]
                (
                  number
                  (.
                    if (!StringToDouble(t->val,value)) {
                      std::string e="Cannot parse double '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                  .)
                |
                  double
                  (.
                    if (!StringToDouble(t->val,value)) {
                      std::string e="Cannot parse double '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                  .)
                )
                (.
                  if (negate) {
                    value=-value;
                  }
                .)
                .

  UINT<size_t& value>
              = number
                (.
                  if (!StringToNumber(t->val,value)) {
                    std::string e="Cannot parse number '"+std::string(t->val)+"'";

                    SemErr(e.c_str());
                  }
                .)
                | variable
                  (.
                    StyleConstantRef constant=config.GetConstantByName(t->val+1);

                    if (!constant) {
                      std::string e="Constant not defined";

                      SemErr(e.c_str());
                    }
                    else {
                      StyleConstantUInt* uintConstant=dynamic_cast<StyleConstantUInt*>(constant.get());
                      if (uintConstant==nullptr) {
                        std::string e="Constant is not of type 'UINT'";

                        SemErr(e.c_str());
                      }
                      else {
                        value=uintConstant->GetUInt();
                      }
                    }
                  .)
                .

  UMAP<double& width>
              = (.
                  StyleConstantRef constant;
                .)
                (
                  UDOUBLE<width> "m"
                | CONSTANT<constant>
                )

                (.
                  if (constant) {
                    StyleConstantWidth* widthConstant=dynamic_cast<StyleConstantWidth*>(constant.get());
                    if (widthConstant==nullptr) {
                      std::string e="Constant is not of type 'WIDTH'";

                      SemErr(e.c_str());
                    }
                    else {
                      if (widthConstant->GetUnit()!=StyleConstantWidth::Unit::m) {
                        std::string e="Constant is not of unit 'm'";

                        SemErr(e.c_str());
                      }
                      else {
                        width=widthConstant->GetWidth();
                      }
                    }
                  }

                  if (!errors->hasErrors) {
                    if (width<0.0) {
                      std::string e="Width must be >= 0.0";

                      SemErr(e.c_str());
                    }
                  }
                .)
                .

  IFCOND<bool& state>
              =  (.
                   std::string flag;
                   bool        negate=false;
                 .)
                 ["!" (. negate=true; .)]
                 IDENT<flag>
                 (.
                   if (!config.HasFlag(flag)) {
                     std::string e="Flag '" + flag +"' is unknown, ignoring";

                     SemErr(e.c_str());
                     state=false;
                   }
                   else {
                     state=config.GetFlagByName(flag);
                   }

                   if (negate) {
                     state=!state;
                   }
                 .)
                 .
END OSS.

