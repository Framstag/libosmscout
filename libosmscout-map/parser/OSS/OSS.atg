#include <iostream>
#include <limits>
#include <list>
#include <sstream>

#include <osmscout/Pixel.h>

#include <osmscout/TypeConfig.h>

#include <osmscout/util/String.h>
#include <osmscout/util/Transformation.h>

COMPILER OSS

typedef std::list<FillStyleRef>       FillStyleList;
typedef std::list<BorderStyleRef>     BorderStyleList;
typedef std::list<IconStyleRef>       IconStyleList;
typedef std::list<TextStyleRef>       TextStyleList;
typedef std::list<LineStyleRef>       LineStyleList;
typedef std::list<PathTextStyleRef>   PathTextStyleList;
typedef std::list<PathShieldStyleRef> PathShieldStyleList;

StyleConfig&                          config;
MagnificationConverter                magnificationConverter;
bool                                  state;

inline std::string Destring(const char* str)
{
  std::string result(str);

  if (result.length()>=2 &&
      result[0]=='"' &&
      result[result.length()-1]=='"') {
    result=result.substr(1,result.length()-2);
  }

  return result;
}

inline bool StringToDouble(const char* string, double& value)
{
  std::istringstream buffer(string);

  buffer.imbue(std::locale::classic());

  buffer >> value;

  return !buffer.fail() && !buffer.bad() && buffer.eof();
}

inline size_t GetHexDigitValue(char c)
{
  if (c>='0' && c<='9') {
    return c-'0';
  }
  else if (c>='a' && c<='f') {
    return 10+(c-'a');
  }

  assert(false);
  return 0;
}

inline void ToRGBA(const std::string& str, Color& color)
{
  double r=(16*GetHexDigitValue(str[1])+GetHexDigitValue(str[2]))/255.0;
  double g=(16*GetHexDigitValue(str[3])+GetHexDigitValue(str[4]))/255.0;
  double b=(16*GetHexDigitValue(str[5])+GetHexDigitValue(str[6]))/255.0;
  double a;

  if (str.length()==9) {
    a=(16*GetHexDigitValue(str[7])+GetHexDigitValue(str[8]))/255.0;
  }
  else {
    a=1.0;
  }

  color=Color(r,g,b,a);
}

CHARACTERS
  letter     = 'a'..'z' + 'A'..'Z'.
  digit      = '0'..'9'.
  hexdigit   = 'a'..'f' + '0'..'9'.
  eol        = '\n'.
  stringchar = ANY - '"'.
  quotchar   = ANY.

TOKENS
  ident      = ('_' | letter) {letter | digit | '_'}.
  number     = digit {digit}.
  double     = digit {digit} '.' digit {digit}.
  color      = "#" hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit [hexdigit hexdigit].
  variable   = "@" ('_' | letter) {letter | digit | '_'}.
  string     = '"' {stringchar | '\\' quotchar} '"'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO eol

IGNORE ' ' + '\t' + '\r' + '\n'

PRODUCTIONS
  OSS         = SYNC "OSS"
                (. state=true; .)
                {
                  FLAGSECTION
                }
                [
                  WAYORDER
                ]
                {
                  CONSTSECTION
                }
                {
                  SYMBOLSECTION
                }
                {
                  STYLESECTION
                }
                "END"
                .

  FLAGSECTION = SYNC "FLAG"
                FLAGBLOCK<true>
                .

  FLAGBLOCK<bool state>
              = {
                    FLAGDEF
                  | FLAGCONDBLOCK<state>
                }
                .

  FLAGCONDBLOCK<bool state>
              =  (.
                   bool newState=state;
                   bool executed=false;
                 .)
                 "IF"
                 IFCOND<newState>
                 "{"
                 (.
                   this->state=state && newState;
                 .)
                 FLAGBLOCK<state && newState>
                 (.
                   this->state=state;
                   executed=newState;
                 .)
                 "}"
                 {
                   "ELIF"
                   IFCOND<newState>
                   "{"
                   (.
                     this->state=!executed && state && newState;
                   .)
                   FLAGBLOCK<!executed && state && newState>
                   (.
                     this->state=state;
                     executed=newState;
                   .)
                   "}"
                 }
                 [
                   "ELSE"
                   "{"
                   (.
                     this->state=!executed && state;
                   .)
                   FLAGBLOCK<!executed && state>
                   (.
                     this->state=state;
                   .)
                   "}"
                 ]
                 .

  FLAGDEF     = (.
                  std::string name;
                  bool        value;
                .)
                IDENT<name>
                "="
                BOOL<value>
                (.
                  if (state) {
                    if (!config.HasFlag(name)) {
                      config.AddFlag(name,value);
                    }
                  }
                .)
                ";"
                .

  WAYORDER    = SYNC "ORDER" "WAYS"
                (. size_t priority=1;.)
                {
                  WAYGROUP<priority>
                  (. priority++;.)
                }
                .

  WAYGROUP<size_t priority>
              = SYNC "GROUP"
                [
                  (.
                     std::string wayTypeName;
                     TypeInfoRef wayType;
                  .)
                  IDENT<wayTypeName>
                  (.
                      wayType=config.GetTypeConfig()->GetTypeInfo(wayTypeName);

                      if (!wayType) {
                        std::string e="Unknown way type '"+wayTypeName+"'";
                        SemWarning(e.c_str());
                      }
                      else if (!wayType->CanBeWay()) {
                        std::string e="Tyype '"+wayTypeName+"' is not a way type";
                        SemErr(e.c_str());
                      }
                      else {
                        config.SetWayPrio(wayType,
                                          priority);
                      }
                  .)
                ]
                {
                  (.
                     std::string wayTypeName;
                     TypeInfoRef wayType;
                  .)
                  ","
                  IDENT<wayTypeName>
                  (.
                      wayType=config.GetTypeConfig()->GetTypeInfo(wayTypeName);

                      if (!wayType) {
                        std::string e="Unknown way type '"+wayTypeName+"'";
                        SemWarning(e.c_str());
                      }
                      else if (!wayType->CanBeWay()) {
                        std::string e="Tyype '"+wayTypeName+"' is not a way type";
                        SemErr(e.c_str());
                      }
                      else {
                        config.SetWayPrio(wayType,
                                          priority);
                      }
                  .)
                }
                .

  SYMBOLSECTION
              = SYNC "SYMBOL"
                (.
                  std::string name;
                .)
                IDENT<name>
                (.
                  SymbolRef symbol=std::make_shared<Symbol>(name);
                .)
                {
                  POLYGON<*symbol>
                | RECTANGLE<*symbol>
                | CIRCLE<*symbol>
                }
                (.
                  if (!config.RegisterSymbol(symbol)) {
                    std::string e="Map symbol '"+symbol->GetName()+"' is already defined";
                    SemErr(e.c_str());
                  }
                .)
                .

  AREAFILLSYMSTYLE<FillPartialStyle& fillStyle>
              = SYNC "{"
                {
                  FILLSTYLEATTR<fillStyle> WEAK ";"
                }
                "}"
                .

  AREABORDERSYMSTYLE<BorderPartialStyle& borderStyle>
              = SYNC "BORDER" "{"
                {
                  BORDERSTYLEATTR<borderStyle> WEAK ";"
                }
                "}"
                .

  AREASYMBOLSTYLE<FillPartialStyle& fillStyle, BorderPartialStyle& borderStyle>
              = SYNC "{"
                {
                  SYNC "AREA" 
                  (  
                    AREAFILLSYMSTYLE<fillStyle>
                  | "."
                    (
                      AREABORDERSYMSTYLE<borderStyle>
                    )  
                  )  
                }
                SYNC "}"
                .

  POLYGON<Symbol& symbol>
              = SYNC "POLYGON"
                (.
                  StyleFilter         filter;
                  FillPartialStyle    fillStyle;
                  BorderPartialStyle  borderStyle;
                  PolygonPrimitiveRef polygon=std::make_shared<PolygonPrimitive>(fillStyle.style,
                                                                                 borderStyle.style);
                  Vertex2D            coord;
                .)
                COORD<coord>   (. polygon->AddCoord(coord); .)
                COORD<coord>   (. polygon->AddCoord(coord); .)
                {
                  COORD<coord> (. polygon->AddCoord(coord); .)
                }
                AREASYMBOLSTYLE<fillStyle,borderStyle>
                (. symbol.AddPrimitive(polygon); .)
                .

  RECTANGLE<Symbol& symbol>
              = SYNC "RECTANGLE"
                (.
                  StyleFilter        filter;
                  FillPartialStyle   fillStyle;
                  BorderPartialStyle borderStyle;
                  Vertex2D           topLeft;
                  double             width;
                  double             height;
                .)
                COORD<topLeft>
                UDOUBLE<width>
                "x"
                UDOUBLE<height>

                AREASYMBOLSTYLE<fillStyle,borderStyle>
                (.
                  symbol.AddPrimitive(std::make_shared<RectanglePrimitive>(topLeft,
                                                                           width,height,
                                                                           fillStyle.style,
                                                                           borderStyle.style));
                .)
                .

  CIRCLE<Symbol& symbol>
              = SYNC "CIRCLE"
                (.
                  Vertex2D           center;
                  double             radius;
                  StyleFilter        filter;
                  FillPartialStyle   fillStyle;
                  BorderPartialStyle borderStyle;
                .)
                COORD<center>
                UDOUBLE<radius>
                AREASYMBOLSTYLE<fillStyle,borderStyle>
                (.
                  symbol.AddPrimitive(std::make_shared<CirclePrimitive>(center,
                                                                        radius,
                                                                        fillStyle.style,
                                                                        borderStyle.style));
                .)
                .

  COORD<Vertex2D& coord>
              = (.
                  double x;
                  double y;
                .)
                DOUBLE<x>
                 ","
                DOUBLE<y>
                (. coord=Vertex2D(x,y); .)
                .

  CONSTSECTION
              = SYNC "CONST"
                CONSTBLOCK<true>
                .

  CONSTBLOCK<bool state>
              = {
                    CONSTCONDBLOCK<state>
                  | CONSTDEF ";"
                }
                .

  CONSTCONDBLOCK<bool state>
              =  (.
                   bool newState=state;
                   bool executed=false;
                 .)
                 "IF"
                 IFCOND<newState>
                 "{"
                 (.
                   this->state=state && newState;
                 .)
                 CONSTBLOCK<state && newState>
                 (.
                   this->state=state;
                   executed=newState;
                 .)
                 "}"
                 {
                   "ELIF"
                   IFCOND<newState>
                   "{"
                   (.
                     this->state=!executed && state && newState;
                   .)
                   CONSTBLOCK<!executed && state && newState>
                   (.
                     this->state=state;
                     executed=newState;
                   .)
                   "}"
                 }
                 [
                   "ELSE"
                   "{"
                   (.
                     this->state=!executed && state;
                   .)
                   CONSTBLOCK<!executed && state>
                   (.
                     this->state=state;
                   .)
                   "}"
                 ]
                 .

  CONSTDEF
              =   COLORCONSTDEF
                | MAGCONSTDEF
                | UINTCONSTDEF
                .

  COLORCONSTDEF
              = (.
                  std::string      name;
                  StyleConstantRef constant;
                  Color            color;
                .)
                "COLOR"
                IDENT<name>
                "="
                COLOR<color>
                (.
                  if (state) {
                    constant=config.GetConstantByName(name);

                    if (constant) {
                      std::string e="Constant already defined";

                      SemErr(e.c_str());
                    }

                    if (!errors->hasErrors) {
                      config.AddConstant(name,std::make_shared<StyleConstantColor>(color));
                    }
                  }
                .)
                .

  MAGCONSTDEF
              = (.
                  std::string      name;
                  StyleConstantRef constant;
                  Magnification    magnification;
                .)
                "MAG"
                IDENT<name>
                "="
                MAG<magnification>
                (.
                  if (state) {
                    constant=config.GetConstantByName(name);

                    if (constant) {
                      std::string e="Constant already defined";

                      SemErr(e.c_str());
                    }

                    if (!errors->hasErrors) {
                      config.AddConstant(name,std::make_shared<StyleConstantMag>(magnification));
                    }
                  }
                .)
                .

  UINTCONSTDEF
              = (.
                  std::string      name;
                  StyleConstantRef constant;
                  size_t           value;
                .)
                "UINT"
                IDENT<name>
                "="
                UINT<value>
                (.
                  if (state) {
                    constant=config.GetConstantByName(name);

                    if (constant) {
                      std::string e="Constant already defined";

                      SemErr(e.c_str());
                    }

                    if (!errors->hasErrors) {
                      config.AddConstant(name,std::make_shared<StyleConstantUInt>(value));
                    }
                  }
                .)
                .

  STYLESECTION
              = "STYLE"
                (. StyleFilter filter; .)
                STYLEBLOCK<filter,true>
                .

  STYLEBLOCK<StyleFilter filter, bool state>
              =
                {
                  (
                      STYLE<filter,state>
                    | STYLECONDBLOCK<filter,state>
                  )
                }
                .

  STYLE<StyleFilter filter, bool state>
              = [
                  STYLEFILTER<filter>
                ]
                (
                  (
                    "{"
                    STYLEBLOCK<filter,state>
                    "}"
                  )
                  | STYLEDEF<filter,state>
                )
                .

  STYLECONDBLOCK<StyleFilter filter, bool state>
              =  (.
                    bool newState=state;
                    bool executed=false;
                 .)
                 "IF"
                 IFCOND<newState>
                 "{"
                 (.
                   this->state=state && newState;
                 .)
                 STYLEBLOCK<filter,state && newState>
                 (.
                   this->state=state;
                   executed=newState;
                 .)
                 "}"
                 {
                   "ELIF"
                   IFCOND<newState>
                   "{"
                   (.
                     this->state=!executed && state && newState;
                   .)
                   STYLEBLOCK<filter,!executed && state && newState>
                   (.
                     this->state=state;
                     executed=newState;
                   .)
                   "}"
                 }
                 [
                   "ELSE"
                   "{"
                   (.
                     this->state=!executed && state;
                   .)
                   STYLEBLOCK<filter,!executed && state>
                   (.
                     this->state=state;
                   .)
                   "}"
                 ]
                 .

  STYLEFILTER<StyleFilter& filter>
              = "["
                   [
                     STYLEFILTER_GROUP<filter>
                   ]
                   [
                     STYLEFILTER_FEATURE<filter>
                   ]
                   [
                     STYLEFILTER_PATH<filter>
                   ]
                   [
                     STYLEFILTER_TYPE<filter>
                   ]
                   [
                     STYLEFILTER_MAG<filter>
                   ]
                   [
                     STYLEFILTER_ONEWAY<filter>
                   ]
                   [
                     STYLEFILTER_BRIDGE<filter>
                   ]
                   [
                     STYLEFILTER_TUNNEL<filter>
                   ]
                   [
                     STYLEFILTER_SIZE<filter>
                   ]
                "]"
                .

  STYLEFILTER_GROUP<StyleFilter& filter>
              = (.
                   TypeInfoSet types;
                   std::string groupName;
                .)
                "GROUP"
                IDENT<groupName>
                (.
                  for (const auto& type : config.GetTypeConfig()->GetTypes()) {
                    if (type->IsInGroup(groupName)) {
                      if (filter.HasTypes() &&
                          !filter.HasType(type)) {
                        continue;
                      }

                      types.Set(type);
                    }
                  }
                .)
                {
                  (. std::string groupName; .)
                  ","
                  IDENT<groupName>
                  (.
                    for (const auto& type : config.GetTypeConfig()->GetTypes()) {
                      if (types.IsSet(type) &&
                          !type->IsInGroup(groupName)) {
                        types.Remove(type);
                      }
                    }
                  .)
                }

                (. filter.SetTypes(types); .)
                .

  STYLEFILTER_FEATURE<StyleFilter& filter>
              = (.
                  TypeInfoSet types;
                  std::string featureName;
                .)
                "FEATURE"
                IDENT<featureName>
                (.
                  FeatureRef feature=config.GetTypeConfig()->GetFeature(featureName);

                  if (!feature) {
                    std::string e="Unknown feature '"+featureName+"'";

                    SemErr(e.c_str());
                  }
                  else {
                    for (const auto& type : config.GetTypeConfig()->GetTypes()) {
                       if (type->HasFeature(featureName)) {
                         if (filter.HasTypes() &&
                             !filter.HasType(type)) {
                           continue;
                         }

                         types.Set(type);
                       }
                    }
                  }
                .)
                {
                  (. std::string featureName; .)
                  ","
                  IDENT<featureName>
                  (.
                    FeatureRef feature=config.GetTypeConfig()->GetFeature(featureName);

                    if (!feature) {
                      std::string e="Unknown feature '"+featureName+"'";

                      SemErr(e.c_str());
                    }
                    else {
                      for (const auto& type : config.GetTypeConfig()->GetTypes()) {
                         if (types.IsSet(type) &&
                             !type->HasFeature(featureName)) {
                           types.Remove(type);
                         }
                      }
                    }
                  .)
                }

                (. filter.SetTypes(types); .)
                .

  STYLEFILTER_PATH<StyleFilter& filter>
              = (.
                  TypeInfoSet types;
                 .)
                "PATH"
                (.
                  for (const auto& type : config.GetTypeConfig()->GetTypes()) {
                    if (type->IsPath()) {
                      if (filter.HasTypes() &&
                          !filter.HasType(type)) {
                        continue;
                      }

                      types.Set(type);
                    }
                  }

                  filter.SetTypes(types);
                .)
                .

  STYLEFILTER_TYPE<StyleFilter& filter>
              = (.
                  TypeInfoSet types;
                  std::string name;
                .)

                "TYPE"
                IDENT<name>
                (.
                  TypeInfoRef type=config.GetTypeConfig()->GetTypeInfo(name);

                  if (!type) {
                    std::string e="Unknown type '"+name+"'";

                    SemWarning(e.c_str());
                  }
                  else if (filter.HasTypes() &&
                           !filter.HasType(type)) {
                    std::string e="Type '"+name+"' is not included by parent filter";

                    SemErr(e.c_str());
                  }
                  else {
                    types.Set(type);
                  }
                .)
                {
                  (. std::string name; .)
                  ","
                  IDENT<name>
                  (.
                    TypeInfoRef type=config.GetTypeConfig()->GetTypeInfo(name);

                    if (!type) {
                      std::string e="Unknown type '"+name+"'";

                      SemWarning(e.c_str());
                    }
                    else if (filter.HasTypes() &&
                             !filter.HasType(type)) {
                      std::string e="Type '"+name+"' is not included by parent filter";

                      SemErr(e.c_str());
                    }
                    else {
                      types.Set(type);
                    }
                  .)
                }

                (. filter.SetTypes(types); .)
                .

  STYLEFILTER_MAG<StyleFilter& filter>
              = "MAG"
                [
                  (. Magnification magnification; .)
                  MAG<magnification>
                  (.
                     size_t level=magnification.GetLevel();

                     if (level<filter.GetMinLevel()) {
                      std::string e="The magnification interval start is not within the parent magnification range";

                      SemErr(e.c_str());
                     }
                     else {
                       filter.SetMinLevel(level);
                     }
                  .)
                ]
                "-"
                [
                  (. Magnification magnification; .)
                  MAG<magnification>
                  (.
                     size_t level=magnification.GetLevel();

                     if (level>filter.GetMaxLevel()) {
                      std::string e="The magnification interval end is not within the parent magnification range";

                      SemErr(e.c_str());
                     }
                     else {
                       filter.SetMaxLevel(level);
                     }
                  .)
                ]
                .

  STYLEFILTER_ONEWAY<StyleFilter& filter>
              = "ONEWAY"
                (.
                  filter.SetOneway(true);
                .)
                .

  STYLEFILTER_BRIDGE<StyleFilter& filter>
              = "BRIDGE"
                (.
                  filter.SetBridge(true);
                .)
                .

  STYLEFILTER_TUNNEL<StyleFilter& filter>
              = "TUNNEL"
                (.
                  filter.SetTunnel(true);
                .)
                .

  STYLEFILTER_SIZE<StyleFilter& filter>
              = (. SizeConditionRef sizeCondition; .)
                "SIZE"
                SIZECONDITION<sizeCondition>
                (. filter.SetSizeCondition(sizeCondition); .)
                .

  SIZECONDITION<SizeConditionRef& condition>
              = (.
                  condition=std::make_shared<SizeCondition>();
                  double widthInMeter;
                .)

                UDOUBLE<widthInMeter> "m"
                (.
                  if (widthInMeter<0.0) {
                   std::string e="Width must be >= 0.0";

                   SemErr(e.c_str());
                  }
                .)

                [
                  [
                    (. double minMM; .)
                    UDOUBLE<minMM> "mm"
                    (. if (widthInMeter>0.0) {
                         condition->SetMinMM(minMM/widthInMeter);
                       }
                    .)
                  ]
                  ":"
                  [
                    (. double minPx; .)
                    UDOUBLE<minPx> "px"
                    (. if (widthInMeter>0.0) {
                         condition->SetMinPx(minPx/widthInMeter);
                        }
                    .)
                  ]
                ]
                "<"
                [
                  [
                    (. double maxMM; .)
                    UDOUBLE<maxMM> "mm"
                    (. if (widthInMeter>0.0) {
                         condition->SetMaxMM(maxMM/widthInMeter);
                       }
                    .)
                  ]
                  ":"
                  [
                    (. double maxPx; .)
                    UDOUBLE<maxPx> "px"
                    (. if (widthInMeter>0.0) {
                         condition->SetMaxPx(maxPx/widthInMeter);
                       }
                    .)
                  ]
                ]
                .

  STYLEDEF<StyleFilter filter, bool state>
              =   NODESTYLEDEF<filter,state>
                | WAYSTYLEDEF<filter,state>
                | AREASTYLEDEF<filter,state>
                .

  NODESTYLEDEF<StyleFilter filter, bool state>
              = SYNC "NODE" "."
                (
                  NODETEXTSTYLE<filter,state>
                | NODEICONSTYLE<filter,state>
                )
                .

  NODETEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "TEXT"
                (.
                  TextPartialStyle style;
                  std::string      slot;
                .)
                [
                  "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                  TEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddNodeTextStyle(filter,style);
                  }
                .)
                .

  NODEICONSTYLE<StyleFilter filter, bool state>
              = SYNC "ICON"
                (.
                  IconPartialStyle style;
                .)
                SYNC "{"
                {
                  ICONSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddNodeIconStyle(filter,style);
                  }
                .)
                .

  WAYSTYLEDEF<StyleFilter filter, bool state>
              = SYNC "WAY"
                (
                  WAYSTYLE<filter,state>
                | "."
                  (
                     WAYPATHTEXTSTYLE<filter,state>
                  |  WAYPATHSYMBOLSTYLE<filter,state>
                  |  WAYSHIELDSTYLE<filter,state>
                  )
                )
                .

  WAYSTYLE<StyleFilter filter, bool state>
              = (.
                  LinePartialStyle style;
                  std::string      slot;
                .)
                [
                  "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                   LINESTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddWayLineStyle(filter,style);
                  }
                .)
                .

  WAYPATHTEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "TEXT"
                (.
                  PathTextPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHTEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddWayPathTextStyle(filter,style);
                  }
                .)
                .

  WAYPATHSYMBOLSTYLE<StyleFilter filter, bool state>
              = SYNC "SYMBOL"
                (.
                  PathSymbolPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHSYMBOLSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddWayPathSymbolStyle(filter,style);
                  }
                .)
                .

  WAYSHIELDSTYLE<StyleFilter filter, bool state>
              = SYNC "SHIELD"
                (.
                  PathShieldPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHSHIELDSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddWayPathShieldStyle(filter,style);
                  }
                .)
                .

  AREASTYLEDEF<StyleFilter filter, bool state>
              = SYNC "AREA"
                (
                  AREASTYLE<filter,state>
                | "."
                  (
                    AREATEXTSTYLE<filter,state>
                  | AREAICONSTYLE<filter,state>
                  | AREABORDERSTYLE<filter,state>
                  | AREABORDERTEXTSTYLE<filter,state>
                  | AREABORDERSYMBOLSTYLE<filter,state>
                  )
                )
                .

  AREASTYLE<StyleFilter filter, bool state>
              = (.
                  FillPartialStyle style;
                .)
                SYNC "{"
                {
                  FILLSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaFillStyle(filter,style);
                  }
                .)
                .


  AREATEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "TEXT"
                (.
                  TextPartialStyle style;
                  std::string      slot;
                .)
                [
                  "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                  TEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaTextStyle(filter,style);
                  }
                .)
                .

  AREAICONSTYLE<StyleFilter filter, bool state>
              = SYNC "ICON"
                (.
                  IconPartialStyle style;
                .)
                SYNC "{"
                {
                  ICONSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaIconStyle(filter,style);
                  }
                .)
                .

  AREABORDERSTYLE<StyleFilter filter, bool state>
              = SYNC "BORDER"
                (.
                  BorderPartialStyle style;
                  std::string        slot;
                .)
                [
                  "#"
                  IDENT<slot> (. style.style->SetSlot(slot); .)
                ]
                SYNC "{"
                {
                  BORDERSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaBorderStyle(filter,style);
                  }
                .)
                .

  AREABORDERTEXTSTYLE<StyleFilter filter, bool state>
              = SYNC "BORDERTEXT"
                (.
                  PathTextPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHTEXTSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaBorderTextStyle(filter,style);
                  }
                .)
                .

  AREABORDERSYMBOLSTYLE<StyleFilter filter, bool state>
              = SYNC "BORDERSYMBOL"
                (.
                  PathSymbolPartialStyle style;
                .)
                SYNC "{"
                {
                  PATHSYMBOLSTYLEATTR<style> WEAK ";"
                }
                SYNC "}"
                (.
                  if (state) {
                    config.AddAreaBorderSymbolStyle(filter,style);
                  }
                .)
                .

  LINESTYLEATTR<LinePartialStyle& style>
              = (
                  (. Color lineColor; .)
                  "color" ":" COLOR<lineColor>
                  (.
                     style.style->SetLineColor(lineColor);
                     style.attributes.insert(LineStyle::attrLineColor);
                  .)
                | (.
                    std::vector<double> dashes;
                    double              dash;
                   .)
                  "dash" ":"
                   UDOUBLE<dash>   (. dashes.push_back(dash); .)
                  {
                    ","
                    UDOUBLE<dash>  (. dashes.push_back(dash); .)
                  }
                  (.
                     style.style->SetDashes(dashes);
                     style.attributes.insert(LineStyle::attrDashes);
                  .)
                | (. Color gapColor; .)
                  "gapColor" ":" COLOR<gapColor>
                  (.
                     style.style->SetGapColor(gapColor);
                     style.attributes.insert(LineStyle::attrGapColor);
                  .)
                | (. double displayWidth; .)
                  "displayWidth" ":"  UDISPLAYSIZE<displayWidth>
                  (.
                     style.style->SetDisplayWidth(displayWidth);
                     style.attributes.insert(LineStyle::attrDisplayWidth);
                  .)
                | (. double width; .)
                  "width" ":" UMAPSIZE<width>
                  (.
                     style.style->SetWidth(width);
                     style.attributes.insert(LineStyle::attrWidth);
                  .)
                | (. double displayOffset; .)
                  "displayOffset" ":"  DISPLAYSIZE<displayOffset>
                  (.
                     style.style->SetDisplayOffset(displayOffset);
                     style.attributes.insert(LineStyle::attrDisplayOffset);
                  .)
                | (. double offset; .)
                  "offset" ":" MAPSIZE<offset>
                  (.
                     style.style->SetOffset(offset);
                     style.attributes.insert(LineStyle::attrOffset);
                  .)
                | (. LineStyle::CapStyle capStyle; .)
                  "cap" ":" CAPSTYLE<capStyle>
                  (.
                     style.style->SetJoinCap(capStyle);
                     style.attributes.insert(LineStyle::attrJoinCap);

                     style.style->SetEndCap(capStyle);
                     style.attributes.insert(LineStyle::attrEndCap);
                  .)
                | (. LineStyle::CapStyle capStyle; .)
                  "joinCap" ":" CAPSTYLE<capStyle>
                  (.
                     style.style->SetJoinCap(capStyle);
                     style.attributes.insert(LineStyle::attrJoinCap);
                  .)
                | (. LineStyle::CapStyle capStyle; .)
                  "endCap" ":" CAPSTYLE<capStyle>
                  (.
                     style.style->SetEndCap(capStyle);
                     style.attributes.insert(LineStyle::attrEndCap);
                  .)
                | (. int priority; .)
                  "priority" ":" INT<priority>
                  (.
                     style.style->SetPriority(priority);
                     style.attributes.insert(LineStyle::attrPriority);
                  .)
                | (. int zIndex; .)
                  "zIndex" ":" INT<zIndex>
                  (.
                     style.style->SetZIndex(zIndex);
                     style.attributes.insert(LineStyle::attrZIndex);
                  .)
                )
                .

  FILLSTYLEATTR<FillPartialStyle& style>
              = (
                  (. Color fillColor; .)
                  "color" ":" COLOR<fillColor>
                  (.
                     style.style->SetFillColor(fillColor);
                     style.attributes.insert(FillStyle::attrFillColor);
                  .)
                | (. std::string patternName; .)
                  "pattern" ":" STRING<patternName>
                  (.
                     style.style->SetPattern(patternName);
                     style.attributes.insert(FillStyle::attrPattern);
                  .)
                | (. Magnification minMag; .)
                  "patternMinMag" ":" MAG<minMag>
                  (.
                     style.style->SetPatternMinMag(minMag);
                     style.attributes.insert(FillStyle::attrPatternMinMag);
                  .)
                )
                .

  BORDERSTYLEATTR<BorderPartialStyle& style>
              = (
                | (. Color color; .)
                  "color" ":" COLOR<color>
                  (.
                     style.style->SetColor(color);
                     style.attributes.insert(BorderStyle::attrColor);
                  .)
                | (. double width; .)
                  "width" ":" UDISPLAYSIZE<width>
                  (.
                     style.style->SetWidth(width);
                     style.attributes.insert(BorderStyle::attrWidth);
                  .)
                | (.
                    std::vector<double> dashes;
                    double              dash;
                   .)
                  "dash" ":"
                   UDOUBLE<dash>   (. dashes.push_back(dash); .)
                  {
                    ","
                    UDOUBLE<dash>  (. dashes.push_back(dash); .)
                  }
                  (.
                     style.style->SetDashes(dashes);
                     style.attributes.insert(BorderStyle::attrDashes);
                  .)
                | (. double displayOffset; .)
                  "displayOffset" ":"  DISPLAYSIZE<displayOffset>
                  (.
                     style.style->SetDisplayOffset(displayOffset);
                     style.attributes.insert(BorderStyle::attrDisplayOffset);
                  .)
                | (. double offset; .)
                  "offset" ":" MAPSIZE<offset>
                  (.
                     style.style->SetOffset(offset);
                     style.attributes.insert(BorderStyle::attrOffset);
                  .)
                | (. int priority; .)
                  "priority" ":" INT<priority>
                  (.
                     style.style->SetPriority(priority);
                     style.attributes.insert(BorderStyle::attrPriority);
                  .)
                )
                .

  TEXTSTYLEATTR<TextPartialStyle& style>
              = (
                  (. LabelProviderRef label; .)
                  "label" ":" TEXTLABEL<label>
                  (.
                     if (label) {
                       style.style->SetLabel(label);
                       style.attributes.insert(TextStyle::attrLabel);
                     }
                  .)
                | (. TextStyle::Style labelStyle; .)
                  "style" ":" LABELSTYLE<labelStyle>
                  (.
                     style.style->SetStyle(labelStyle);
                     style.attributes.insert(TextStyle::attrStyle);
                  .)
                | (. Color textColor; .)
                  "color" ":" COLOR<textColor>
                  (.
                     style.style->SetTextColor(textColor);
                     style.attributes.insert(TextStyle::attrTextColor);
                  .)
                | (. double size; .)
                  "size" ":" UDOUBLE<size>
                  (.
                     style.style->SetSize(size);
                     style.attributes.insert(TextStyle::attrSize);
                  .)
                | (. Magnification scaleMag; .)
                  "scaleMag" ":" MAG<scaleMag>
                  (.
                     style.style->SetScaleAndFadeMag(scaleMag);
                     style.attributes.insert(TextStyle::attrScaleAndFadeMag);
                  .)
                | (. bool autoSize; .)
                  "autoSize" ":" BOOL<autoSize>
                  (.
                     style.style->SetAutoSize(autoSize);
                     style.attributes.insert(TextStyle::attrAutoSize);
                  .)
                | (. size_t priority; .)
                  "priority" ":" UINT<priority>
                  (.
                    style.style->SetPriority((uint8_t)priority);
                    style.attributes.insert(TextStyle::attrPriority);
                  .)
                | (. size_t position; .)
                  "position" ":" UINT<position>
                  (.
                    style.style->SetPosition(position);
                    style.attributes.insert(TextStyle::attrPosition);
                  .)
                )
                .

  PATHSHIELDSTYLEATTR<PathShieldPartialStyle& style>
              = (
                  (. LabelProviderRef label; .)
                  "label" ":" TEXTLABEL<label>
                  (.
                     if (label) {
                       style.style->SetLabel(label);
                       style.attributes.insert(PathShieldStyle::attrLabel);
                     }
                  .)
                | (. Color textColor; .)
                  "color" ":" COLOR<textColor>
                  (.
                     style.style->SetTextColor(textColor);
                     style.attributes.insert(PathShieldStyle::attrTextColor);
                  .)
                | (. Color bgColor; .)
                  "backgroundColor" ":" COLOR<bgColor>
                  (.
                     style.style->SetBgColor(bgColor);
                     style.attributes.insert(PathShieldStyle::attrBgColor);
                  .)
                | (. Color borderColor; .)
                  "borderColor" ":" COLOR<borderColor>
                  (.
                     style.style->SetBorderColor(borderColor);
                     style.attributes.insert(PathShieldStyle::attrBorderColor);
                  .)
                | (. double size; .)
                  "size" ":" UDOUBLE<size>
                  (.
                     style.style->SetSize(size);
                     style.attributes.insert(PathShieldStyle::attrSize);
                  .)
                | (. size_t priority; .)
                  "priority" ":" UINT<priority>
                  (.
                    if (priority<std::numeric_limits<uint8_t>::max()) {
                      style.style->SetPriority((uint8_t)priority);
                      style.attributes.insert(PathShieldStyle::attrPriority);
                    }
                    else {
                      std::string e="Priority must be in the interval [0,"+
                                    NumberToString(std::numeric_limits<uint8_t>::max())+"[";

                      SemErr(e.c_str());
                    }
                  .)
                | (. double shieldSpace; .)
                  "shieldSpace" ":" UDISPLAYSIZE<shieldSpace>
                  (.
                     style.style->SetShieldSpace(shieldSpace);
                     style.attributes.insert(PathShieldStyle::attrShieldSpace);
                  .)
                )
                .

  PATHTEXTSTYLEATTR<PathTextPartialStyle& style>
              = (
                  (. LabelProviderRef label; .)
                  "label" ":" TEXTLABEL<label>
                  (.
                     if (label) {
                       style.style->SetLabel(label);
                       style.attributes.insert(PathTextStyle::attrLabel);
                     }
                  .)
                | (. Color textColor; .)
                  "color" ":" COLOR<textColor>
                  (.
                     style.style->SetTextColor(textColor);
                     style.attributes.insert(PathTextStyle::attrTextColor);
                  .)
                | (. double size; .)
                  "size" ":" UDOUBLE<size>
                  (.
                     style.style->SetSize(size);
                     style.attributes.insert(PathTextStyle::attrSize);
                  .)
                | (. double displayOffset; .)
                  "displayOffset" ":"  DISPLAYSIZE<displayOffset>
                  (.
                     style.style->SetDisplayOffset(displayOffset);
                     style.attributes.insert(PathTextStyle::attrDisplayOffset);
                  .)
                | (. double offset; .)
                  "offset" ":" MAPSIZE<offset>
                  (.
                     style.style->SetOffset(offset);
                     style.attributes.insert(PathTextStyle::attrOffset);
                  .)
                )
                .

  PATHSYMBOLSTYLEATTR<PathSymbolPartialStyle& style>
              = (
                  (.
                    std::string name;
                    SymbolRef   symbol;
                   .)
                  "symbol" ":" IDENT<name>
                  (.
                     symbol=config.GetSymbol(name);

                     if (!symbol) {
                       std::string e="Map symbol '"+name+"' is not defined";

                       SemErr(e.c_str());
                     }
                     else {
                       style.style->SetSymbol(symbol);
                       style.attributes.insert(PathSymbolStyle::attrSymbol);
                     }
                  .)
                | (. double symbolSpace; .)
                  "symbolSpace" ":" UDISPLAYSIZE<symbolSpace>
                  (.
                     style.style->SetSymbolSpace(symbolSpace);
                     style.attributes.insert(PathSymbolStyle::attrSymbolSpace);
                  .)
                | (. double displayOffset; .)
                  "displayOffset" ":"  DISPLAYSIZE<displayOffset>
                  (.
                     style.style->SetDisplayOffset(displayOffset);
                     style.attributes.insert(PathSymbolStyle::attrDisplayOffset);
                  .)
                | (. double offset; .)
                  "offset" ":" MAPSIZE<offset>
                  (.
                     style.style->SetOffset(offset);
                     style.attributes.insert(PathSymbolStyle::attrOffset);
                  .)
                )
                .

  ICONSTYLEATTR<IconPartialStyle& style>
              = (
                  (.
                    std::string name;
                    SymbolRef   symbol;
                   .)
                  "symbol" ":" IDENT<name>
                  (.
                     symbol=config.GetSymbol(name);

                     if (!symbol) {
                       std::string e="Map symbol '"+name+"' is not defined";

                       SemErr(e.c_str());
                     }
                     else {
                       style.style->SetSymbol(symbol);
                       style.attributes.insert(IconStyle::attrSymbol);
                     }
                  .)
                | (. std::string name; .)
                  "name" ":" IDENT<name>
                  (.
                      style.style->SetIconName(name);
                      style.attributes.insert(IconStyle::attrIconName);
                  .)
                | (. size_t position; .)
                  "position" ":" UINT<position>
                  (.
                    style.style->SetPosition(position);
                    style.attributes.insert(IconStyle::attrPosition);
                  .)
                )
                .

  CAPSTYLE<LineStyle::CapStyle& style>
              = (
                  "butt"    (. style=LineStyle::capButt; .)
                | "round"   (. style=LineStyle::capRound; .)
                | "square"  (. style=LineStyle::capSquare; .)
                ).

  LABELSTYLE<TextStyle::Style& style>
              = (
                  "normal"    (. style=TextStyle::normal; .)
                | "emphasize" (. style=TextStyle::emphasize; .)
                ).

  TEXTLABEL<LabelProviderRef& label>
              = (.
                  std::string featureName;
                  std::string labelName;
                 .)
                IDENT<featureName>
                [
                  "."
                  // This is a hack, since "name" is a reserved token, we could not have a IDENT name...
                  ( IDENT<labelName> | "name" (. labelName="name"; .) )
                ]
                (.
                  if (!labelName.empty()) {
                    FeatureRef feature;

                    feature=config.GetTypeConfig()->GetFeature(featureName);

                    if (!feature) {
                      std::string e="'"+featureName+"' is not a registered feature";

                      SemErr(e.c_str());
                      return;
                    }

                    if (!feature->HasLabel()) {
                      std::string e="'"+featureName+"' does not support labels";

                      SemErr(e.c_str());
                      return;
                    }

                    size_t labelIndex;

                    if (!feature->GetLabelIndex(labelName,
                                                labelIndex)) {
                      std::string e="'"+featureName+"' does not have a label named '"+labelName+"'";

                      SemErr(e.c_str());
                      return;
                    }

                    label=std::make_shared<DynamicFeatureLabelReader>(*config.GetTypeConfig(),
                                                                      featureName,
                                                                      labelName);
                  }
                  else {
                    label=config.GetLabelProvider(featureName);

                    if (!label) {
                      std::string e="There is no label provider with name '"+featureName+"' registered";

                      SemErr(e.c_str());
                      return;
                    }
                  }
                .)
                .

  COLOR<Color& color>
              =   (. double factor; .)
                  "lighten" "(" COLOR<color> "," UDOUBLE<factor> ")"
                  (.
                    if (factor>=0.0 && factor<=1.0) {
                      color=color.Lighten(factor);
                    }
                    else {
                     std::string e="Factor must be in the range [0..1]";

                      SemErr(e.c_str());
                    }
                  .)
                | (. double factor; .)
                  "darken" "(" COLOR<color> "," UDOUBLE<factor> ")"
                  (.
                    if (factor>=0.0 && factor<=1.0) {
                      color=color.Darken(factor);
                    }
                    else {
                     std::string e="Factor must be in the range [0..1]";

                      SemErr(e.c_str());
                    }
                  .)
                | color
                  (.
                    std::string c(t->val);

                    if (c.length()!=7 &&
                        c.length()!=9) {
                      std::string e="Illegal color value";
                      SemErr(e.c_str());
                    }

                    if (!errors->hasErrors) {
                      ToRGBA(c,color);
                    }
                  .)
                | variable
                  (.
                    StyleConstantRef constant=config.GetConstantByName(t->val+1);

                    if (!constant) {
                      std::string e="Constant not defined";

                      SemErr(e.c_str());

                      color=Color::BLACK;
                    }
                    else if (dynamic_cast<StyleConstantColor*>(constant.get())==NULL) {
                      std::string e="Constant is not of type 'COLOR'";

                      SemErr(e.c_str());

                      color=Color::BLACK;
                    }
                    else {
                      StyleConstantColor* colorConstant=dynamic_cast<StyleConstantColor*>(constant.get());

                      color=colorConstant->GetColor();
                    }
                  .)
                .

  MAG<Magnification& magnification>
              = (
                  (. std::string name; .)
                  IDENT<name>
                  (.
                    if (!magnificationConverter.Convert(name,magnification)) {
                      std::string e="'"+std::string(name)+"' is not a valid magnification level";

                      SemErr(e.c_str());
                    }
                  .)
                )
                |
                (
                  (. size_t level; .)
                  number
                  (.
                    if (!StringToNumber(t->val,level)) {
                      std::string e="Cannot parse number '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                    else {
                      magnification.SetLevel((uint32_t)level);
                    }
                  .)
                )
                | variable
                  (.
                    StyleConstantRef constant=config.GetConstantByName(t->val+1);

                    if (!constant) {
                      std::string e="Constant not defined";

                      SemErr(e.c_str());
                    }
                    else if (dynamic_cast<StyleConstantMag*>(constant.get())==NULL) {
                      std::string e="Variable is not of type 'MAG'";

                      SemErr(e.c_str());
                    }

                    if (!errors->hasErrors) {
                      StyleConstantMag* magConstant=dynamic_cast<StyleConstantMag*>(constant.get());

                      magnification=magConstant->GetMag();
                    }
                  .)
               .

  /* Size in units of screen (currently millimeter) */
  UDISPLAYSIZE <double& value>
              = UDOUBLE<value> "mm".

  /* Size in units of screen (currently millimeter) */
  DISPLAYSIZE <double& value>
              = DOUBLE<value> "mm".

  /* Size in units of map (currently meter) */
  UMAPSIZE <double& value>
              = UDOUBLE<value> "m".

  /* Size in units of map (currently meter) */
  MAPSIZE <double& value>
              = DOUBLE<value> "m".

  IDENT<std::string& value>
              = ident
                (.
                  value=t->val;
                .)
                .

  BOOL<bool& value>
              = (. std::string ident; .)
                ident
                (.
                  ident=t->val;

                  if (ident=="true") {
                    value=true;
                  }
                  else if (ident=="false") {
                    value=false;
                  }
                  else {
                    std::string e="'"+std::string(t->val)+"' is not a valid boolean value, only 'true' and 'false' are allowed";

                    SemErr(e.c_str());

                    value=false;
                  }
                .)
                .

  STRING<std::string& value>
              = string
                (.
                  value=Destring(t->val);
                .)
                .

  UDOUBLE<double& value>
              =   number
                  (.
                    if (!StringToDouble(t->val,value)) {
                      std::string e="Cannot parse double '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                  .)
                | double
                  (.
                    if (!StringToDouble(t->val,value)) {
                      std::string e="Cannot parse double '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                  .)
                .

  DOUBLE<double& value>
              = (. bool negate=false; .)
                [
                  "-" (. negate=true; .)
                ]
                (
                  number
                  (.
                    if (!StringToDouble(t->val,value)) {
                      std::string e="Cannot parse double '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                  .)
                |
                  double
                  (.
                    if (!StringToDouble(t->val,value)) {
                      std::string e="Cannot parse double '"+std::string(t->val)+"'";

                      SemErr(e.c_str());
                    }
                  .)
                )
                (.
                  if (negate) {
                    value=-value;
                  }
                .)
                .

  INT<int& value>
              = (. bool negate=false; .)
                [
                  "-" (. negate=true; .)
                ]
                number
                (.
                  if (!StringToNumber(t->val,value)) {
                    std::string e="Cannot parse number '"+std::string(t->val)+"'";

                    SemErr(e.c_str());
                  }
                .)
                (.
                  if (negate) {
                    value=-value;
                  }
                .)
                .

  UINT<size_t& value>
              = number
                (.
                  if (!StringToNumber(t->val,value)) {
                    std::string e="Cannot parse number '"+std::string(t->val)+"'";

                    SemErr(e.c_str());
                  }
                .)
                | variable
                  (.
                    StyleConstantRef constant=config.GetConstantByName(t->val+1);

                    if (!constant) {
                      std::string e="Constant not defined";

                      SemErr(e.c_str());
                    }
                    else if (dynamic_cast<StyleConstantUInt*>(constant.get())==NULL) {
                      std::string e="Constant is not of type 'UINT'";

                      SemErr(e.c_str());
                    }

                    if (!errors->hasErrors) {
                      StyleConstantUInt* uintConstant=dynamic_cast<StyleConstantUInt*>(constant.get());

                      value=uintConstant->GetUInt();
                    }
                  .)
                .
  IFCOND<bool& state>
              =  (.
                   std::string flag;
                   bool        negate=false;
                 .)
                 ["!" (. negate=true; .)]
                 IDENT<flag>
                 (.
                   if (!config.HasFlag(flag)) {
                     std::string e="Flag '" + flag +"' is unknown, ignoring";

                     SemErr(e.c_str());
                     state=false;
                   }
                   else {
                     state=config.GetFlagByName(flag);
                   }

                   if (negate) {
                     state=!state;
                   }
                 .)
                 .
END OSS.

